# HiPart is a software toolkit to analyse molecular densities with the hirshfeld partitioning scheme.
# Copyright (C) 2007 - 2010 Toon Verstraelen <Toon.Verstraelen@UGent.be>
#
# This file is part of HiPart.
#
# HiPart is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# HiPart is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>
#
# --


# TODO: also evaluate overlap matrices in the basis of contracted gaussians
# TODO: Support for Gaussian/GAMESS wfn files.
# TODO: Extend hi-atomdb.py to work with GAMESS
# TODO: Implement the potential generated by an atomic density, and evaluate it
# on grids of other atoms. This can be used to compute QM-level electrostatic
# interaction energies. (See Becke's paper http://dx.doi.org/10.1063/1.455005)
# TODO: Compute condensed linear response properties
# TODO: Support for CP2K and CPMD wavefunctions
# TODO: Visualize Atomic deviations from sphericity (1D plots)
# TODO: Visualization of atomic (pair) data with graphs
# TODO: Cube files with atomic weights and densities
# TODO: use smaller lebedev grids close to the cusps


from hipart.log import log
from hipart.io import dump_atom_scalars, dump_atom_vectors, dump_atom_matrix, \
    dump_atom_fields
from hipart.fit import ESPCostFunction
from hipart.lebedev_laikov import get_grid, get_atom_grid, integrate_lebedev
from hipart.atoms import AtomTable, AtomFn
from hipart.grids import Grid
from hipart.spline import get_radial_weights_log

from molmod import Rotation, angstrom
from molmod.periodic import periodic

import os, numpy


__all__ = ["ComputeError", "ParseError", "cache_classes"]


noble_numbers = numpy.array([0,2,10,18,36,54,86,118])
core_sizes = dict((number, noble_numbers[noble_numbers<=number].max()) for number in periodic.iter_numbers())


class ComputeError(Exception):
    pass

class ParseError(Exception):
    pass


class OnlyOnce(object):
    def __init__(self, description):
        self.description = description

    def __call__(self, fn):
        def wrapper(instance):
            if fn.func_name in instance._done:
                return
            log.begin(self.description)
            fn(instance)
            log.end()
            instance._done.add(fn.func_name)
        wrapper.__doc__ = fn.__doc__
        return wrapper


class BaseCache(object):
    prefix = None
    usage = None

    @classmethod
    def new_from_args(cls, context, args):
        raise NotImplementedError

    def __init__(self, context, extra_tag_attributes):
        self.context = context
        rs = self.get_rs(-1)
        extra_tag_attributes.update({
            "r_low": "%.2e" % rs.min(),
            "r_high": "%.2e" % rs.max(),
            "r_steps": "%i" % len(rs),

        })
        self.context.check_tag(extra_tag_attributes)
        self._done = set([])

    def get_rs(self, i):
        raise NotImplementedError

    @OnlyOnce("Integration weights")
    def do_integration_weights(self):
        self.radial_weights_map = {}
        molecule = self.context.wavefn.molecule
        for i in xrange(molecule.size):
            rs = self.get_rs(i)
            key = len(rs)
            if key in self.radial_weights_map:
                continue
            weights = get_radial_weights_log(rs)
            self.radial_weights_map[key] = weights

    def _radint(self, i, integrand):
        """Radial integration routine"""
        molecule = self.context.wavefn.molecule
        rs = self.get_rs(i)
        w = self.radial_weights_map[len(rs)]
        return numpy.dot(w, integrand*rs*rs)

    def _radint_cumul(self, i, integrand):
        # WARNING: this is very inaccurate, do not use for delicate computations
        molecule = self.context.wavefn.molecule
        rs = self.get_rs(i)
        w = self.radial_weights_map[len(rs)]
        return numpy.cumsum(w*integrand*rs*rs)

    @OnlyOnce("Atomic grids")
    def do_atgrids(self):
        molecule = self.context.wavefn.molecule
        workdir = self.context.workdir

        self.atgrids = []
        pb = log.pb("Computing/Loading atomic grids (and distances)", molecule.size**2)
        for i in xrange(molecule.size):
            prefix = os.path.join(workdir, "atom%05i" % i)
            atgrid = Grid.from_prefix(prefix)
            rs = self.get_rs(i)
            num_points = len(self.context.lebedev_xyz.shape)*len(rs)
            if atgrid is None or atgrid.points.shape != (num_points,3):
                center = molecule.coordinates[i]
                points = get_atom_grid(self.context.lebedev_xyz, center, rs)
                atgrid = Grid(prefix, points)
            self.atgrids.append(atgrid)

            # Compute and store all the distances from these grid points to the
            # nuclei.
            atgrid.distances = []
            for j in xrange(molecule.size):
                pb()
                distances = numpy.sqrt(((atgrid.points - molecule.coordinates[j])**2).sum(axis=1))
                # distances from grid points of atom i to atom j.
                atgrid.distances.append(distances)
        pb()

    @OnlyOnce("Molecular density on atomic grids")
    def do_atgrids_moldens(self):
        self.do_atgrids()
        molecule = self.context.wavefn.molecule
        pb = log.pb("Computing/Loading densities", molecule.size)
        for i in xrange(molecule.size):
            pb()
            self.context.wavefn.compute_density(self.atgrids[i])
        pb()

    @OnlyOnce("Molecular spin density on atomic grids")
    def do_atgrids_molspindens(self):
        self.do_atgrids()
        molecule = self.context.wavefn.molecule
        pb = log.pb("Computing/Loading spin densities", molecule.size)
        for i in xrange(molecule.size):
            pb()
            self.context.wavefn.compute_spin_density(self.atgrids[i])
        pb()

    @OnlyOnce("Estimating noble gas core radii")
    def do_noble_radii(self):
        molecule = self.context.wavefn.molecule
        workdir = self.context.workdir

        noble_radii_fn_bin = os.path.join(workdir, "noble_radii.bin")
        if os.path.isfile(noble_radii_fn_bin):
            log("Loading noble radii")
            self.noble_radii = numpy.fromfile(noble_radii_fn_bin, float)
        else:
            self.do_integration_weights()
            self.do_atgrids_moldens()
            log("Computing noble radii")
            self.noble_radii = numpy.zeros(molecule.size, float)
            for i, number_i in enumerate(molecule.numbers):
                if number_i < 3:
                    self.noble_radii[i] = 0.2
                else:
                    densities = self.atgrids[i].moldens
                    radfun = integrate_lebedev(self.context.lebedev_weights, densities)
                    charge_int = self._radint_cumul(i, radfun)
                    rs = self.get_rs(i)
                    j = charge_int.searchsorted([core_sizes[number_i]])[0]
                    self.noble_radii[i] = rs[j]
            self.noble_radii.tofile(noble_radii_fn_bin)

    @OnlyOnce("Computing the ESP cost function")
    def do_esp_costfunction(self):
        # TODO: the ESP cost function should be upgraded to a more reliable
        # implementation. We should consider the cost function as an integral
        # over the volume where the density is not too high and the distance
        # from the molecule is not too far. This can be achieved by a
        # combination of Becke's integration scheme
        # (http://dx.doi.org/10.1063/1.454033) and Hu's ESP method
        # (http://dx.doi.org/10.1021/ct600295n). Then there is no need to
        # construct a molecular grid. The atomic grids are sufficient.
        # TODO: output ESP charges in the same way as the stockholder charges.
        self.do_molgrid_moldens()
        self.do_molgrid_molpot()

        total_charge = self.context.wavefn.charge
        coordinates = self.context.wavefn.molecule.coordinates
        self.mol_esp_cost = ESPCostFunction(
            coordinates, self.molgrid.points, self.molgrid.weights,
            self.molgrid.moldens, self.molgrid.molpot, total_charge,
        )
        outfn = os.path.join(self.context.outdir, "mol_esp_cost.txt")
        self.mol_esp_cost.write_to_file(outfn)
        log("Written %s" % outfn)

    @OnlyOnce("Molecular grid")
    def do_molgrid(self):
        lebedev_xyz, lebedev_weights = get_grid(50)
        molecule = self.context.wavefn.molecule
        workdir = self.context.workdir

        prefix = os.path.join(workdir, "molecule")
        self.do_noble_radii()

        self.molgrid = Grid.from_prefix(prefix)
        if self.molgrid is not None:
            self.molgrid.weights = self.molgrid.load("weights")
        else:
            # we have to generate a new grid. The grid is constructed taking
            # into account the following considerations:
            # 1) Grid points within the cusp region are discarded
            # 2) The rest of the molecular and surrounding volume is sampled
            #    with spherical grids centered on the atoms. Around each atom,
            #    'scale_steps' of shells are placed with lebedev grid points
            #    (num_lebedev). The lebedev weights are used in the fit to
            #    avoid preferential directions within one shell.
            # 3) The radii of the shells start from scale_min*(cusp_radius+0.2)
            #    and go up to scale_max*(cusp_radius+0.2).
            # 4) Each shell will be randomly rotated around the atom to avoid
            #    global preferential directions in the grid.
            # 5) The default parameters for the grid should be sufficient for
            #    sane ESP fitting. The ESP cost function should discard points
            #    with a density larger than a threshold, i.e. 1e-5 a.u. A
            #    gradual transition between included and discarded points around
            #    this threshold will improve the quality of the fit.

            scale_min = 1.5
            scale_max = 30.0
            scale_steps = 30
            scale_factor = (scale_max/scale_min)**(1.0/(scale_steps-1))
            scales = scale_min*scale_factor**numpy.arange(scale_steps)

            points = []
            weights = []
            pb = log.pb("Constructing molecular grid", scale_steps)
            for scale in scales:
                pb()
                radii = scale*self.noble_radii
                for i in xrange(molecule.size):
                    rot = Rotation.random()
                    for j in xrange(len(lebedev_xyz)):
                        my_point = radii[i]*numpy.dot(rot.r, lebedev_xyz[j]) + molecule.coordinates[i]
                        distances = numpy.sqrt(((molecule.coordinates - my_point)**2).sum(axis=1))
                        if (distances < scales[0]*self.noble_radii).any():
                            continue
                        points.append(my_point)
                        weights.append(lebedev_weights[j])
            pb()
            points = numpy.array(points)
            weights = numpy.array(weights)

            self.molgrid = Grid(prefix, points)
            self.molgrid.weights = weights
            self.molgrid.dump("weights", weights)

    @OnlyOnce("Molecular density on the molecular grid")
    def do_molgrid_moldens(self):
        self.do_molgrid()
        self.context.wavefn.compute_density(self.molgrid)

    @OnlyOnce("Molecular potential on the molecular grid")
    def do_molgrid_molpot(self):
        self.do_molgrid()
        log("This may take a minute. Hang on.")
        self.context.wavefn.compute_potential(self.molgrid)

    def _prepare_atweights(self):
        pass

    @OnlyOnce("Defining atomic weight functions (each on their own atomic grid)")
    def do_atgrids_atweights(self):
        log("Trying to load weight functions")
        success = self._load_atgrid_atweights()
        if not success:
            log("Could not load all weight functions from workdir. Computing them...")
            self._prepare_atweights()
            self._compute_atgrid_atweights()
            log("Writing results to workdir")
            self._dump_atgrid_atweights()

    def _load_atgrid_atweights(self):
        molecule = self.context.wavefn.molecule

        ws = []
        for i in xrange(molecule.size):
            w = self.atgrids[i].load("%s_atweights" % self.prefix)
            if w is None:
                return False
            else:
                ws.append(w)

        for i in xrange(molecule.size):
            self.atgrids[i].atweights = ws[i]
        return True

    def _compute_atgrid_atweights(self):
        raise NotImplementedError

    def _dump_atgrid_atweights(self):
        molecule = self.context.wavefn.molecule
        for i in xrange(molecule.size):
            self.atgrids[i].dump("%s_atweights" % self.prefix, self.atgrids[i].atweights)

    @OnlyOnce("Atomic charges")
    def do_charges(self):
        charges_fn_bin = os.path.join(self.context.workdir, "%s_charges.bin" % self.prefix)
        populations_fn_bin = os.path.join(self.context.workdir, "%s_populations.bin" % self.prefix)
        molecule = self.context.wavefn.molecule

        if os.path.isfile(charges_fn_bin) and os.path.isfile(populations_fn_bin):
            log("Loading charges.")
            self.charges = numpy.fromfile(charges_fn_bin, float)
            self.populations = numpy.fromfile(populations_fn_bin, float)
        else:
            self.do_integration_weights()
            self.do_atgrids()
            self.do_atgrids_moldens()
            self.do_atgrids_atweights()

            pb = log.pb("Computing charges", molecule.size)
            self.populations = numpy.zeros(molecule.size, float)
            self.charges = numpy.zeros(molecule.size, float)
            for i in xrange(molecule.size):
                pb()
                w = self.atgrids[i].atweights
                d = self.atgrids[i].moldens
                center = molecule.coordinates[i]

                integrand = d*w
                radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                self.populations[i] = self._radint(i, radfun)
                self.charges[i] = molecule.numbers[i] - self.populations[i]
            pb()
            self.populations.tofile(populations_fn_bin)
            if self.context.options.fix_total_charge:
                self.charges -= (self.charges.sum() - self.context.wavefn.charge)/molecule.size
            self.charges.tofile(charges_fn_bin)

        charges_fn = os.path.join(self.context.outdir, "%s_charges.txt" % self.prefix)
        dump_atom_scalars(charges_fn, self.charges, molecule.numbers)
        log("Written %s" % charges_fn)

    @OnlyOnce("Atomic spin charges")
    def do_spin_charges(self):
        spin_charges_fn_bin = os.path.join(self.context.workdir, "%s_spin_charges.bin" % self.prefix)
        molecule = self.context.wavefn.molecule

        if os.path.isfile(spin_charges_fn_bin):
            log("Loading spin charges.")
            self.spin_charges = numpy.fromfile(spin_charges_fn_bin, float)
        else:
            self.do_integration_weights()
            self.do_atgrids()
            self.do_atgrids_molspindens()
            self.do_atgrids_atweights()

            pb = log.pb("Computing spin charges", molecule.size)
            self.spin_charges = numpy.zeros(molecule.size, float)
            for i in xrange(molecule.size):
                pb()
                w = self.atgrids[i].atweights
                d = self.atgrids[i].molspindens
                center = molecule.coordinates[i]

                integrand = d*w
                radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                self.spin_charges[i] = self._radint(i, radfun)
            pb()
            self.spin_charges.tofile(spin_charges_fn_bin)

        spin_charges_fn = os.path.join(self.context.outdir, "%s_spin_charges.txt" % self.prefix)
        dump_atom_scalars(spin_charges_fn, self.spin_charges, molecule.numbers, name="Spin charge")
        log("Written %s" % spin_charges_fn)

    @OnlyOnce("Atomic dipoles")
    def do_dipoles(self):
        dipoles_fn_bin = os.path.join(self.context.workdir, "%s_dipoles.bin" % self.prefix)
        molecule = self.context.wavefn.molecule

        if os.path.isfile(dipoles_fn_bin):
            log("Loading dipoles.")
            self.dipoles = numpy.fromfile(dipoles_fn_bin, float).reshape((molecule.size,3))
        else:
            self.do_integration_weights()
            self.do_atgrids()
            self.do_atgrids_moldens()
            self.do_atgrids_atweights()

            pb = log.pb("Computing dipoles", molecule.size)
            self.dipoles = numpy.zeros((molecule.size,3), float)
            for i in xrange(molecule.size):
                pb()
                atgrid = self.atgrids[i]
                w = atgrid.atweights
                d = atgrid.moldens
                center = molecule.coordinates[i]

                for j in 0,1,2:
                    integrand = -(atgrid.points[:,j] - center[j])*d*w
                    radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                    self.dipoles[i,j] = self._radint(i, radfun)
            pb()
            self.dipoles.tofile(dipoles_fn_bin)

        # now some nice output
        dipoles_fn = os.path.join(self.context.outdir, "%s_dipoles.txt" % self.prefix)
        dump_atom_vectors(dipoles_fn, self.dipoles, molecule.numbers)
        log("Written %s" % dipoles_fn)

    @OnlyOnce("Atomic multipoles (up to hexadecapols)")
    def do_multipoles(self):
        regular_solid_harmonics = [
            lambda x,y,z: 1.0, # (0,0)
            lambda x,y,z: z, # (1,0)
            lambda x,y,z: x, # (1,1+)
            lambda x,y,z: y, # (1,1-)
            lambda x,y,z: 1.0*z**2 - 0.5*x**2 - 0.5*y**2, # (2,0)
            lambda x,y,z: 1.7320508075688772935*x*z, # (2,1+)
            lambda x,y,z: 1.7320508075688772935*y*z, # (2,1-)
            lambda x,y,z: 0.86602540378443864676*x**2 - 0.86602540378443864676*y**2, # (2,2+)
            lambda x,y,z: 1.7320508075688772935*x*y, # (2,2-)
            lambda x,y,z: -1.5*z*x**2 - 1.5*z*y**2 + z**3, # (3,0)
            lambda x,y,z: 2.4494897427831780982*x*z**2 - 0.61237243569579452455*x*y**2 - 0.61237243569579452455*x**3, # (3,1+)
            lambda x,y,z: 2.4494897427831780982*y*z**2 - 0.61237243569579452455*y*x**2 - 0.61237243569579452455*y**3, # (3,1-)
            lambda x,y,z: 1.9364916731037084426*z*x**2 - 1.9364916731037084426*z*y**2, # (3,2+)
            lambda x,y,z: 3.8729833462074168852*x*y*z, # (3,2-)
            lambda x,y,z: -2.371708245126284499*x*y**2 + 0.790569415042094833*x**3, # (3,3+)
            lambda x,y,z: 2.371708245126284499*y*x**2 - 0.790569415042094833*y**3, # (3,3-)
            lambda x,y,z: 0.75*x**2*y**2 - 3.0*x**2*z**2 - 3.0*y**2*z**2 + z**4 + 0.375*x**4 + 0.375*y**4, # (4,0)
            lambda x,y,z: -2.371708245126284499*x*z*y**2 + 3.162277660168379332*x*z**3 - 2.371708245126284499*z*x**3, # (4,1+)
            lambda x,y,z: -2.371708245126284499*y*z*x**2 + 3.162277660168379332*y*z**3 - 2.371708245126284499*z*y**3, # (4,1-)
            lambda x,y,z: 3.3541019662496845446*x**2*z**2 - 3.3541019662496845446*y**2*z**2 + 0.5590169943749474241*y**4 - 0.5590169943749474241*x**4, # (4,2+)
            lambda x,y,z: 6.7082039324993690892*x*y*z**2 - 1.1180339887498948482*x*y**3 - 1.1180339887498948482*y*x**3, # (4,2-)
            lambda x,y,z: -6.2749501990055666098*x*z*y**2 + 2.0916500663351888699*z*x**3, # (4,3+)
            lambda x,y,z: 6.2749501990055666098*y*z*x**2 - 2.0916500663351888699*z*y**3, # (4,3-)
            lambda x,y,z: -4.4370598373247120319*x**2*y**2 + 0.73950997288745200532*x**4 + 0.73950997288745200532*y**4, # (4,4+)
            lambda x,y,z: 2.9580398915498080213*y*x**3 - 2.9580398915498080213*x*y**3, # (4,4-)
        ]
        labels = [
            '(0,0)', '(1,0)', '(1,1+)', '(1,1-)', '(2,0)', '(2,1+)', '(2,1-)',
            '(2,2+)', '(2,2-)', '(3,0)', '(3,1+)', '(3,1-)', '(3,2+)', '(3,2-)',
            '(3,3+)', '(3,3-)', '(4,0)', '(4,1+)', '(4,1-)', '(4,2+)', '(4,2-)',
            '(4,3+)', '(4,3-)', '(4,4+)', '(4,4-)'
        ]

        multipoles_fn_bin = os.path.join(self.context.workdir, "%s_multipoles.bin" % self.prefix)
        molecule = self.context.wavefn.molecule

        if os.path.isfile(multipoles_fn_bin):
            log("Loading multipoles.")
            num_polys = len(regular_solid_harmonics)
            self.multipoles = numpy.fromfile(multipoles_fn_bin, float).reshape((molecule.size,num_polys))
        else:
            self.do_integration_weights()
            self.do_atgrids()
            self.do_atgrids_moldens()
            self.do_atgrids_atweights()

            pb = log.pb("Computing multipoles", molecule.size)
            num_polys = len(regular_solid_harmonics)
            self.multipoles = numpy.zeros((molecule.size,num_polys), float)
            for i in xrange(molecule.size):
                pb()
                atgrid = self.atgrids[i]
                w = atgrid.atweights
                d = atgrid.moldens
                center = molecule.coordinates[i]

                cx = atgrid.points[:,0] - center[0]
                cy = atgrid.points[:,1] - center[1]
                cz = atgrid.points[:,2] - center[2]
                for j in xrange(num_polys):
                    poly = regular_solid_harmonics[j]
                    integrand = -poly(cx,cy,cz)*d*w
                    radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                    self.multipoles[i,j] = self._radint(i, radfun)
                self.multipoles[i,0] += molecule.numbers[i]
            pb()
            self.multipoles.tofile(multipoles_fn_bin)

        # now some nice output
        multipoles_fn = os.path.join(self.context.outdir, "%s_multipoles.txt" % self.prefix)
        dump_atom_fields(multipoles_fn, self.multipoles, labels, molecule.numbers, "Multipoles")
        log("Written %s" % multipoles_fn)


    @OnlyOnce("Testing charges and dipoles on ESP grid.")
    def do_esp_test(self):
        self.do_charges()
        self.do_dipoles()
        self.do_esp_costfunction()

        molecule = self.context.wavefn.molecule

        filename = os.path.join(self.context.outdir, "%s_esp_test.txt" % self.prefix)
        f = file(filename, "w")
        print >> f, "Reproduction of the molecular dipole"
        print >> f, "-------------------------------------------------------------------------------"
        print >> f, "                  Dipole-X        Dipole-Y        Dipole-Z       Dipole-norm"
        print >> f, "-------------------------------------------------------------------------------"
        dipole_q = (molecule.coordinates*self.charges.reshape((-1,1))).sum(axis=0)
        dipole_p = self.dipoles.sum(axis=0)
        dipole_qp = dipole_q + dipole_p
        dipole_qm = self.context.wavefn.dipole
        print >> f, "charges (q)   % 15.12f % 15.12f % 15.12f % 15.12f" % (
            dipole_q[0], dipole_q[1], dipole_q[2], numpy.linalg.norm(dipole_q),
        )
        print >> f, "dipoles (p)   % 15.12f % 15.12f % 15.12f % 15.12f" % (
            dipole_p[0], dipole_p[1], dipole_p[2], numpy.linalg.norm(dipole_p),
        )
        print >> f, "q and p       % 15.12f % 15.12f % 15.12f % 15.12f" % (
            dipole_qp[0], dipole_qp[1], dipole_qp[2], numpy.linalg.norm(dipole_qp),
        )
        print >> f, "total density % 15.12f % 15.12f % 15.12f % 15.12f" % (
            dipole_qm[0], dipole_qm[1], dipole_qm[2], numpy.linalg.norm(dipole_qm),
        )
        print >> f, "-------------------------------------------------------------------------------"
        print >> f
        print >> f, "Reproduction of the external molecular ESP"
        print >> f, "-------------------------------------------------------------"
        print >> f, "                     RMSD             RMS       CORRELATION"
        print >> f, "-------------------------------------------------------------"
        print >> f, "charges (q)      % 10.5e    % 10.5e      % 5.2f" % (
            self.mol_esp_cost.rmsd(self.charges),
            self.mol_esp_cost.model_rms(self.charges),
            self.mol_esp_cost.correlation(self.charges),
        )
        print >> f, "dipoles (p)      % 10.5e    % 10.5e      % 5.2f" % (
            self.mol_esp_cost.rmsd(None, self.dipoles),
            self.mol_esp_cost.model_rms(None, self.dipoles),
            self.mol_esp_cost.correlation(None, self.dipoles),
        )
        print >> f, "q and p          % 10.5e    % 10.5e      % 5.2f" % (
            self.mol_esp_cost.rmsd(self.charges, self.dipoles),
            self.mol_esp_cost.model_rms(self.charges, self.dipoles),
            self.mol_esp_cost.correlation(self.charges, self.dipoles),
        )
        print >> f, "total density                    % 10.5e" % self.mol_esp_cost.rms
        print >> f, "-------------------------------------------------------------"
        f.close()
        log("Written %s" % filename)


    @OnlyOnce("Evaluating orbitals on atomic grids")
    def do_atgrids_orbitals(self):
        self.do_atgrids()
        molecule = self.context.wavefn.molecule
        num_orbitals = self.context.wavefn.num_orbitals
        workdir = self.context.workdir

        self.context.wavefn.init_naturals(workdir)
        pb = log.pb("Computing/Loading orbitals", molecule.size)
        for i in xrange(molecule.size):
            pb()
            self.context.wavefn.compute_orbitals(self.atgrids[i])
        pb()

    @OnlyOnce("Atomic overlap matrices")
    def do_atgrids_overlap_matrix_orb(self):
        # Note that the overlap matrices are computed in the basis of the
        # orbitals. Each kind of overlap matrix is thus computed in the basis
        # of its corresponding kind of orbitals.
        self.do_atgrids()

        def do_one_kind(kind):
            # first check for restricted
            molecule = self.context.wavefn.molecule
            orbitals = getattr(self.context.wavefn, "%s_orbitals" % kind)
            if kind!="alpha" and self.context.wavefn.alpha_orbitals is orbitals:
                # simply make references to alpha data and return
                log("Cloning alpha results (%s)" % kind)
                for i in xrange(molecule.size):
                    setattr(self.atgrids[i], "%s_overlap_matrix_orb" % kind, self.atgrids[i].alpha_overlap_matrix_orb)
                return

            # then try to load the matrices
            some_failed = False
            num_orbitals = self.context.wavefn.num_orbitals
            for i in xrange(molecule.size):
                matrix = self.atgrids[i].load("%s_%s_overlap_matrix_orb" % (self.prefix, kind))
                if matrix is None:
                    some_failed = True
                else:
                    matrix = matrix.reshape((num_orbitals, num_orbitals))
                setattr(self.atgrids[i], "%s_overlap_matrix_orb" % kind, matrix)

            if some_failed:
                self.do_integration_weights()
                self.do_atgrids_orbitals()
                self.do_atgrids_atweights()

                pb = log.pb("Computing atomic overlap matrices (%s)" % kind, molecule.size)
                for i in xrange(molecule.size):
                    pb()
                    if getattr(self.atgrids[i], "%s_overlap_matrix_orb" % kind) is None:
                        orbitals = getattr(self.atgrids[i], "%s_orbitals" % kind)
                        w = self.atgrids[i].atweights
                        matrix = numpy.zeros((num_orbitals,num_orbitals), float)
                        for j1 in xrange(num_orbitals):
                            for j2 in xrange(j1+1):
                                integrand = orbitals[j1]*orbitals[j2]*w
                                radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                                value = self._radint(i, radfun)
                                matrix[j1,j2] = value
                                matrix[j2,j1] = value
                        setattr(self.atgrids[i], "%s_overlap_matrix_orb" % kind, matrix)
                        self.atgrids[i].dump("%s_%s_overlap_matrix_orb" % (self.prefix, kind), matrix)
                pb()

            filename = os.path.join(self.context.outdir, "%s_%s_overlap_matrices_orb.txt" % (self.prefix, kind))
            f = file(filename, "w")
            print >> f, "number of orbitals:", num_orbitals
            print >> f, "number of atoms: ", molecule.size
            for i, number_i in enumerate(molecule.numbers):
                print >> f, "Atom %i: %s" % (i, periodic[number_i].symbol)
                matrix = getattr(self.atgrids[i], "%s_overlap_matrix_orb" % kind)
                for row in matrix:
                    print >> f, " ".join("% 15.10e" % value for value in row)
            f.close()
            log("Written %s" % filename)

        do_one_kind("alpha")
        do_one_kind("beta")
        do_one_kind("natural")

    @OnlyOnce("Bond orders and valences")
    def do_bond_orders(self):
        # first try to load the results from the work dir
        bond_orders_fn_bin = os.path.join(self.context.workdir, "%s_bond_orders.bin" % self.prefix)
        valences_fn_bin = os.path.join(self.context.workdir, "%s_valences.bin" % self.prefix)
        molecule = self.context.wavefn.molecule
        if os.path.isfile(bond_orders_fn_bin) and os.path.isfile(valences_fn_bin):
            self.bond_orders = numpy.fromfile(bond_orders_fn_bin).reshape((molecule.size, molecule.size))
            self.valences = numpy.fromfile(valences_fn_bin)
        else:
            self.do_charges()
            self.do_atgrids_overlap_matrix_orb()

            self.bond_orders = numpy.zeros((molecule.size, molecule.size))
            self.valences = numpy.zeros(molecule.size)
            num_orbitals = self.context.wavefn.num_orbitals
            n_alpha = self.context.wavefn.num_alpha
            n_beta = self.context.wavefn.num_beta
            n_natural = self.context.wavefn.num_natural
            o_alpha = self.context.wavefn.alpha_occupations[:n_alpha]
            o_beta = self.context.wavefn.beta_occupations[:n_beta]
            o_natural = self.context.wavefn.natural_occupations[:n_natural]

            def get_pm(om, num, occ):
                pm = om[:num,:num].copy()
                tmp = numpy.sqrt(occ)
                pm *= tmp
                pm *= tmp.reshape((-1,1))
                return pm

            def get_correlation(om1, om2, num, occ):
                pm1 = get_pm(om1, num, occ)
                pm2 = get_pm(om2, num, occ)
                return numpy.dot(pm1.ravel(),pm2.ravel())

            pb = log.pb("Computing bond orders", (molecule.size*(molecule.size+1))/2)
            for i in xrange(molecule.size):
                for j in xrange(i+1):
                    pb()
                    if i==j:
                        # compute valence
                        bo = get_correlation(
                            self.atgrids[i].natural_overlap_matrix_orb,
                            self.atgrids[j].natural_overlap_matrix_orb,
                            n_natural, o_natural
                        )
                        self.valences[i] = 2*self.populations[i] - bo
                    else:
                        # compute bond order
                        bo = 2*(
                            get_correlation(
                                self.atgrids[i].alpha_overlap_matrix_orb,
                                self.atgrids[j].alpha_overlap_matrix_orb,
                                n_alpha, o_alpha
                            )+
                            get_correlation(
                                self.atgrids[i].beta_overlap_matrix_orb,
                                self.atgrids[j].beta_overlap_matrix_orb,
                                n_beta, o_beta
                            )
                        )
                        self.bond_orders[i,j] = bo
                        self.bond_orders[j,i] = bo
            pb()
            self.bond_orders.tofile(bond_orders_fn_bin)
            self.valences.tofile(valences_fn_bin)

        bond_orders_fn = os.path.join(self.context.outdir, "%s_bond_orders.txt" % self.prefix)
        dump_atom_matrix(bond_orders_fn, self.bond_orders, molecule.numbers, "Bond order")
        log("Written %s" % bond_orders_fn)

        valences_fn = os.path.join(self.context.outdir, "%s_valences.txt" % self.prefix)
        dump_atom_scalars(valences_fn, self.valences, molecule.numbers, "Valences")
        log("Written %s" % valences_fn)

        free_valences_fn = os.path.join(self.context.outdir, "%s_free_valences.txt" % self.prefix)
        self.free_valences = self.valences - self.bond_orders.sum(axis=1)
        dump_atom_scalars(free_valences_fn, self.free_valences, molecule.numbers, "Free valences")
        log("Written %s" % free_valences_fn)

    @OnlyOnce("Atomic weights on other atoms' grids.")
    def do_atgrids_od_atweights(self):
        # od stands for off-diagonal
        self.do_atgrids_atweights()
        self._prepare_atweights()

        molecule = self.context.wavefn.molecule
        pb = log.pb("Computing off-diagonal atom weights", molecule.size**2)
        for i in xrange(molecule.size):
            atgrid = self.atgrids[i]
            atgrid.od_atweights = []
            for j in xrange(molecule.size):
                pb()
                w = self._compute_atweights(atgrid, j)
                atgrid.od_atweights.append(w)
        pb()

    def _compute_atweights(self, grid, atom_index):
        raise NotImplementedError

    @OnlyOnce("Net and overlap populations")
    def do_net_overlap(self):
        net_overlap_fn_bin = os.path.join(self.context.workdir, "%s_net_overlap.bin" % self.prefix)
        molecule = self.context.wavefn.molecule

        if os.path.isfile(net_overlap_fn_bin):
            log("Loading net and overlap populations.")
            self.net_overlap = numpy.fromfile(net_overlap_fn_bin, float).reshape((molecule.size,molecule.size))
        else:
            self.do_integration_weights()
            self.do_atgrids()
            self.do_atgrids_moldens()
            self.do_charges()
            self.do_atgrids_od_atweights()
            self.net_overlap = numpy.zeros((molecule.size, molecule.size))
            pb = log.pb("Integrating over products of stockholder weights", (molecule.size*(molecule.size+1))/2)
            for i in xrange(molecule.size):
                for j in xrange(i+1):
                    pb()
                    if i != j:
                        # Use Becke's integration scheme to split the integral
                        # over two atomic grids.
                        # 1) first part of the integral, using the grid on atom i
                        rs = self.get_rs(i)
                        delta = (self.atgrids[i].distances[j].reshape((len(rs),-1)) - rs.reshape((-1,1))).ravel()
                        switch = delta/molecule.distance_matrix[i,j]
                        for k in xrange(3):
                            switch = (3 - switch**2)*switch/2
                        switch += 1
                        switch /= 2
                        integrand = switch*self.atgrids[i].od_atweights[j]*self.atgrids[i].atweights*self.atgrids[i].moldens
                        radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                        part1 = self._radint(i, radfun)
                        # 2) second part of the integral
                        rs = self.get_rs(j)
                        delta = (self.atgrids[j].distances[i].reshape((len(rs),-1)) - rs.reshape((-1,1))).ravel()
                        switch = delta/molecule.distance_matrix[i,j]
                        for k in xrange(3):
                            switch = (3 - switch**2)*switch/2
                        switch += 1
                        switch /= 2
                        integrand = switch*self.atgrids[j].od_atweights[i]*self.atgrids[j].atweights*self.atgrids[j].moldens
                        radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                        part2 = self._radint(j, radfun)
                        # Add up and store
                        self.net_overlap[i,j] = part1 + part2
                        self.net_overlap[j,i] = part1 + part2
                    else:
                        integrand = self.atgrids[i].atweights**2*self.atgrids[i].moldens
                        radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                        self.net_overlap[i,i] = self._radint(i, radfun)
            pb()
            self.net_overlap.tofile(net_overlap_fn_bin)

        net_fn = os.path.join(self.context.outdir, "%s_net_overlap.txt" % self.prefix)
        dump_atom_matrix(net_fn, self.net_overlap, molecule.numbers, "Net")


class StockholderCache(BaseCache):
    def do_proatomfns(self):
        raise NotImplementedError

    def _prepare_atweights(self):
        self.do_proatomfns()

    def _compute_atgrid_atweights(self):
        molecule = self.context.wavefn.molecule
        for i in xrange(molecule.size):
            self.atgrids[i].atweights = self._compute_atweights(
                self.atgrids[i], i
            )

    def _compute_atweights(self, grid, atom_index):
        """Return the weight of atom with given index in the given grid points
        """
        molecule = self.context.wavefn.molecule
        # construct the pro-atom and pro-molecule on this grid
        pro_atom = self.proatomfns[atom_index].density(grid.distances[atom_index])
        pro_mol = numpy.zeros(len(pro_atom), float)
        for j in xrange(molecule.size):
            pro_mol += self.proatomfns[j].density(grid.distances[j])
        # multiply the density on the grid by the weight function
        return pro_atom/pro_mol


class TableBaseCache(StockholderCache):
    @classmethod
    def new_from_args(cls, context, args):
        if len(args) == 1:
            atom_table = AtomTable(args[0])
        else:
            raise ParseError("The Hirshfeld schemes require one scheme argument.")
        return cls(context, atom_table)

    def __init__(self, context, extra_tag_attributes, atom_table):
        self.atom_table = atom_table
        BaseCache.__init__(self, context, extra_tag_attributes)
        # write the rs to the workdir for plotting purposes:
        atom_table.rs.tofile(os.path.join(self.context.workdir, "rs.bin"))

    def get_rs(self, i):
        if i == -1:
            return self.atom_table.rs
        else:
            number = self.context.wavefn.molecule.numbers[i]
            return self.atom_table.records[number].rs


hirshfeld_usage = """ * Hirshfeld Partitioning
     scheme = hirsh
     scheme parameters = densities.txt

     The file densities.txt is generated with the script hi-atomdb.py. It
     contains spherically averaged densities of individual atoms. Make sure all
     the atoms present in the molecule of interest are included in the file
     densities.txt

     Hirshfeld, F. L. Theor. Chim. Acta 1977, 44, 129-138.
     http://dx.doi.org/10.1007/BF00549096
"""

class HirshfeldCache(TableBaseCache):
    prefix = "hirsh"
    usage = hirshfeld_usage

    def __init__(self, context, atom_table):
        TableBaseCache.__init__(self, context, {}, atom_table)

    @OnlyOnce("Conventional Hirshfeld (with neutral pro-atoms)")
    def do_proatomfns(self):
        self.do_atgrids()
        molecule = self.context.wavefn.molecule
        self.proatomfns = []
        for i, number_i in enumerate(molecule.numbers):
            self.proatomfns.append(self.atom_table.records[number_i].get_atom_fn(0.0))


hirshfeld_i_usage = """ * Hirshfeld-I Partitioning
     scheme = hirshi
     scheme parameters = densities.txt

     The file densities.txt is generated with the script hi-atomdb.py. It
     contains spherically averaged densities of individual atoms. Make sure all
     the atoms present in the molecule of interest are included in the file
     densities.txt

     Bultinck, P.;  Van Alsenoy, C.;  Ayers, P. W.;  Dorca, R. C. J. Chem. Phys.
     2007, 126, 144111.
     http://dx.doi.org/10.1063/1.2715563
"""

class HirshfeldICache(TableBaseCache):
    prefix = "hirshi"
    usage = hirshfeld_i_usage

    def __init__(self, context, atom_table):
        TableBaseCache.__init__(self, context, {}, atom_table)

    @OnlyOnce("Iterative Hirshfeld")
    def do_proatomfns(self):
        molecule = self.context.wavefn.molecule
        self.do_integration_weights()
        self.do_atgrids_moldens()

        counter = 0
        old_charges = numpy.zeros(molecule.size, float)
        while True:
            # construct the pro-atom density functions, using the densities
            # from the previous iteration.
            self.proatomfns = []
            for i, number_i in enumerate(molecule.numbers):
                self.proatomfns.append(self.atom_table.records[number_i].get_atom_fn(old_charges[i]))

            charges = []
            for i in xrange(molecule.size):
                fn = self.atgrids[i].moldens*self._compute_atweights(self.atgrids[i], i)
                radfun = integrate_lebedev(self.context.lebedev_weights, fn)
                num_electrons = self._radint(i, radfun)
                charges.append(molecule.numbers[i] - num_electrons)

            # ordinary blablabla ...
            charges = numpy.array(charges)
            max_change = abs(charges-old_charges).max()
            log("Iteration %03i    max change = %10.5e    total charge = %10.5e" % (
                counter, max_change, charges.sum()
            ))
            if max_change < self.context.options.threshold:
                break
            counter += 1
            if counter > self.context.options.max_iter:
                raise RuntimeError("Iterative Hirshfeld failed to converge.")
            old_charges = charges


isa_usage = """ * Iterative Stockholder Partitioning
     scheme = isa
     scheme parameters = [r_low r_high steps]

     Three additional parameters can be provided of the file rs.bin is not yet
     present in the work directory. The first two, r_low and r_high, are the
     first and the last point on the logarithmic radial grid in angstrom. The
     third, steps, is the number of grid points on the radial grid. The default
     is 2.0e-5, 20.0 and 100, respectively.

     Lillestolen, T. C.;  Wheatley, R. J. Chem. Commun. 2008,  5909-5911.
     http://dx.doi.org/10.1039/b812691g
"""

class ISACache(StockholderCache):
    prefix = "isa"
    usage = isa_usage

    @classmethod
    def new_from_args(cls, context, args):
        rs_fn_bin = os.path.join(context.workdir, "rs.bin")
        if os.path.isfile(rs_fn_bin):
            rs = numpy.fromfile(rs_fn_bin)
            if len(args) != 0:
                raise ParseError("The ISA scheme requires no arguments when a file rs.bin is present in the work directory.")
        else:
            if len(args) == 3:
                r_low = float(args[0])*angstrom
                r_high = float(args[1])*angstrom
                steps = float(args[2])
            elif len(args) == 0:
                r_low = 2.0e-5*angstrom
                r_high = 20.0*angstrom
                steps = 100
            else:
                raise ParseError("The ISA scheme requires zero or three scheme arguments.")
            ratio = (r_high/r_low)**(1.0/(steps-1))
            alpha = numpy.log(ratio)
            rs = r_low*numpy.exp(alpha*numpy.arange(0,steps))
        return cls(context, rs)

    def __init__(self, context, rs):
        self.rs = rs
        BaseCache.__init__(self, context, {})
        # write the rs to the workdir for plotting purposes:
        self.rs.tofile(os.path.join(self.context.workdir, "rs.bin"))

    def get_rs(self, i):
        if i == -1:
            return self.rs
        elif hasattr(self, "proatomfns") and len(self.proatomfns) > i:
            return self.proatomfns[i].density.x
        elif hasattr(self, "atgrids") and len(self.atgrids) > i:
            num_shells = len(self.atgrids[i].points)/self.context.num_lebedev
            return self.rs[:num_shells]
        else:
            return self.rs

    @OnlyOnce("Iterative Stockholder Analysis")
    def do_proatomfns(self):
        molecule = self.context.wavefn.molecule
        self.do_integration_weights()
        self.do_atgrids_moldens()

        log("Generating initial guess for the pro-atoms")
        self.proatomfns = []
        for i in xrange(molecule.size):
            densities = self.atgrids[i].moldens
            profile = densities.reshape((-1,self.context.num_lebedev)).min(axis=1)
            profile[profile < 1e-6] = 1e-6
            rs = self.get_rs(i)
            self.proatomfns.append(AtomFn(rs, profile))

        counter = 0
        old_charges = numpy.zeros(molecule.size, float)
        while True:
            new_proatomfns = []
            charges = []
            for i in xrange(molecule.size):
                fn = self.atgrids[i].moldens*self._compute_atweights(self.atgrids[i], i)
                radfun = integrate_lebedev(self.context.lebedev_weights, fn)
                num_electrons = self._radint(i, radfun)
                charges.append(molecule.numbers[i] - num_electrons)
                # add negligible tails to maintain a complete partitioning
                radfun[radfun < 1e-40] = 1e-40
                new_proatomfn = AtomFn(rs, radfun/4*numpy.pi)
                new_proatomfns.append(new_proatomfn)

            # ordinary blablabla ...
            charges = numpy.array(charges)
            max_change = abs(charges-old_charges).max()
            log("Iteration %03i    max change = %10.5e    total charge = %10.5e" % (
                counter, max_change, charges.sum()
            ))
            if max_change < self.context.options.threshold:
                break
            counter += 1
            if counter > self.context.options.max_iter:
                raise RuntimeError("Iterative Stockholder Analysis failed to converge.")
            old_charges = charges
            self.proatomfns = new_proatomfns


becke_usage = """ * Becke's Smooth Voronoi Partitioning
     scheme = becke
     scheme parameters = [k] [r_low r_high steps]

     The parameter k is optional and defaults to 3. It is the number of
     iterations in the definition of the weight function in Becke's paper.

     Three additional parameters can be provided of the file rs.bin is not yet
     present in the work directory. The first two, r_low and r_high, are the
     first and the last point on the logarithmic radial grid in angstrom. The
     third, steps, is the number of grid points on the radial grid. The default
     is 2.0e-5, 20.0 and 100, respectively.

     Becke, A. D. J. Chem. Phys. 1988,  88, 2547-2553.
     http://dx.doi.org/10.1063/1.454033
"""

class BeckeCache(BaseCache):
    prefix = "becke"
    usage = becke_usage

    @classmethod
    def new_from_args(cls, context, args):
        rs_fn_bin = os.path.join(context.workdir, "rs.bin")
        if os.path.isfile(rs_fn_bin):
            rs = numpy.fromfile(rs_fn_bin)
            if len(args) == 0:
                k = 3
            elif len(args) == 1:
                k = int(args[0])
            else:
                raise ParseError("The Becke scheme requires zero or one argument(s) when a file rs.bin is present in the work directory.")
        else:
            if len(args) == 3 or len(args) == 4:
                r_low = float(args[-3])*angstrom
                r_high = float(args[-2])*angstrom
                steps = float(args[-1])
            elif len(args) == 0 or len(args) == 1:
                r_low = 2.0e-5*angstrom
                r_high = 20.0*angstrom
                steps = 100
            else:
                raise ParseError("The ISA scheme requires zero or three scheme arguments.")
            if len(args) == 1 or len(args)==4:
                k = int(args[0])
            else:
                k = 3
            ratio = (r_high/r_low)**(1.0/(steps-1))
            alpha = numpy.log(ratio)
            rs = r_low*numpy.exp(alpha*numpy.arange(0,steps))
        if k <= 0:
            raise ValueError("The parameter k must be strictly positive.")
        return cls(context, k, rs)

    def __init__(self, context, k, rs):
        self.k = k
        self.rs = rs
        BaseCache.__init__(self, context, {"becke_k": str(k)})
        # write the rs to the workdir for plotting purposes:
        self.rs.tofile(os.path.join(self.context.workdir, "rs.bin"))

    def get_rs(self, i):
        if i == -1:
            return self.rs
        elif hasattr(self, "proatomfns") and len(self.proatomfns) > i:
            return self.proatomfns[i].density.x
        elif hasattr(self, "atgrids") and len(self.atgrids) > i:
            num_shells = len(self.atgrids[i].points)/self.context.num_lebedev
            return self.rs[:num_shells]
        else:
            return self.rs

    @OnlyOnce("Becke's Smooth Voronoi Partitioning")
    def _prepare_atweights(self):
        # Compute the cell functions on all grids
        self.do_atgrids()
        molecule = self.context.wavefn.molecule
        radii = numpy.array([periodic[n].covalent_radius for n in molecule.numbers])
        N = molecule.size
        pb = log.pb("Computing/Loading cell functions", (N*N*(N-1))/2)
        for i in xrange(N):
            # working in the grid of atom i
            grid = self.atgrids[i]

            # first try to load. if it fails then compute.
            success = True
            grid.cell_functions = []
            for j in xrange(N):
                cell_function = grid.load("cell%05i" % j)
                if cell_function is None:
                    success = False
                    break
                grid.cell_functions.append(cell_function)

            if not success:
                # load failed, so compute
                grid.cell_functions = [1]*N
                for j0 in xrange(N):
                    for j1 in xrange(j0):
                        pb()
                        # working on the contribution from atom pair j0,j1
                        # determine the displacement of the cell boundary with
                        # respect to the center based on covalent radii
                        d = molecule.distance_matrix[j0,j1]
                        u = (radii[j0]-radii[j1])/(radii[j1]+radii[j0])
                        a = u/(u**2-1)
                        if a < -0.45: a = -0.45
                        elif a > 0.45: a = 0.45
                        # construct the switching function
                        switch = (grid.distances[j0] - grid.distances[j1])/d
                        switch = switch + a*(1-switch**2) # hetero
                        for k in xrange(self.k):
                            switch = 0.5*(3.0 - switch**2)*switch
                        switch += 1.0
                        switch /= 2.0
                        grid.cell_functions[j0] *= 1-switch
                        grid.cell_functions[j1] *= switch
                # dump cell functions
                for j in xrange(N):
                    grid.dump("cell%05i" % j, grid.cell_functions[j])
            else:
                pb((N*(N-1))/2)
            grid.cell_sum = sum(grid.cell_functions)
        pb()

    def _compute_atgrid_atweights(self):
        molecule = self.context.wavefn.molecule
        for i in xrange(molecule.size):
            grid = self.atgrids[i]
            grid.atweights = grid.cell_functions[i]/grid.cell_sum

    def _compute_atweights(self, grid, atom_index):
        """Return the weight of atom with given index in the given grid points
        """
        return grid.cell_functions[atom_index]/grid.cell_sum


# find all usable Cache classes
cache_classes = {}
for x in globals().values():
    if isinstance(x, type) and issubclass(x, BaseCache) and x.prefix is not None:
        cache_classes[x.prefix] = x
