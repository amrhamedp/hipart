# HiPart is a software toolkit to analyse molecular densities with the hirshfeld partitioning scheme.
# Copyright (C) 2007 - 2010 Toon Verstraelen <Toon.Verstraelen@UGent.be>
#
# This file is part of HiPart.
#
# HiPart is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# HiPart is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>
#
# --


# TODO: tests for everything, use nosetests and work in /tmp/foo
# TODO: load/dump atom matrices,overlap populations,bond orders to/from work
# TODO: support for unrestricted HF/KS
# TODO: Support for Gaussian/GAMESS wfn files.
# TODO: Extend hi-atomdb.py to work with GAMESS
# TODO: arbitrary multipoles
# TODO: Implement Becke's scheme as one of the population schemes.
# TODO: Implement the potential generated by an atomic density, and evaluate it
# on grids of other atoms. This can be used to compute QM-level electrostatic
# interaction energies. (See Becke's paper )
# TODO: Compute condensed linear response properties
# TODO: Support for fchk files without using cubegen
# TODO: Support for CP2K and CPMD wavefunctions


from hipart.log import log
from hipart.tools import get_atom_grid
from hipart.integrate import cumul_integrate_log, integrate_log, integrate_lebedev
from hipart.fit import ESPCostFunction
from hipart.lebedev_laikov import get_grid
from hipart.atoms import AtomTable, AtomFn
from hipart.grids import Grid

from molmod import Rotation, angstrom
from molmod.periodic import periodic

import os, numpy


__all__ = ["ComputeError", "ParseError", "cache_classes"]


noble_numbers = numpy.array([0,2,10,18,36,54,86,118])
core_sizes = dict((number, noble_numbers[noble_numbers<=number].max()) for number in periodic.iter_numbers())


class ComputeError(Exception):
    pass

class ParseError(Exception):
    pass


class OnlyOnce(object):
    def __init__(self, description):
        self.description = description

    def __call__(self, fn):
        def wrapper(instance):
            if fn.func_name in instance._done:
                return
            log.begin(self.description)
            fn(instance)
            log.end(self.description)
            instance._done.add(fn.func_name)
        wrapper.__doc__ = fn.__doc__
        return wrapper


class BaseCache(object):
    key = None
    usage = None

    @classmethod
    def new_from_args(cls, context, args):
        raise NotImplementedError

    def __init__(self, context, prefix):
        self.prefix = prefix
        self.context = context
        self.context.check_tag(self.get_rs(0,0))
        self._done = set([])

    def get_rs(self, i, number_i):
        raise NotImplementedError

    @OnlyOnce("Atomic grids")
    def do_atgrids(self):
        molecule = self.context.wavefn.molecule
        workdir = self.context.workdir

        self.atgrids = []
        pb = log.pb("Computing/Loading atomic grids (and distances)", molecule.size**2)
        for i, number_i in enumerate(molecule.numbers):
            prefix = os.path.join(workdir, "atom%05i" % i)
            atgrid = Grid.from_prefix(prefix)
            if atgrid is None:
                center = molecule.coordinates[i]
                points = get_atom_grid(
                    self.context.lebedev_xyz, center,
                    self.get_rs(i, number_i),
                )
                atgrid = Grid(prefix, points)
            self.atgrids.append(atgrid)

            # Compute and store all the distances from these grid points to the
            # nuclei.
            atgrid.distances = []
            for j, number_j in enumerate(molecule.numbers):
                pb()
                distances = numpy.sqrt(((atgrid.points - molecule.coordinates[j])**2).sum(axis=1))
                # distances from grid points of atom i to atom j.
                atgrid.distances.append(distances)
        pb()

    @OnlyOnce("Molecular density on atomic grids")
    def do_atgrids_moldens(self):
        self.do_atgrids()
        molecule = self.context.wavefn.molecule
        pb = log.pb("Computing/Loading densities", molecule.size)
        for i, number_i in enumerate(molecule.numbers):
            pb()
            self.context.wavefn.compute_density(self.atgrids[i])
        pb()

    @OnlyOnce("Estimating noble gas core radii")
    def do_noble_radii(self):
        molecule = self.context.wavefn.molecule
        workdir = self.context.workdir

        noble_radii_fn_bin = os.path.join(workdir, "noble_radii.bin")
        if os.path.isfile(noble_radii_fn_bin):
            log("Loading noble radii")
            self.noble_radii = numpy.fromfile(noble_radii_fn_bin, float)
        else:
            self.do_atgrids_moldens()
            log("Computing noble radii")
            self.noble_radii = numpy.zeros(molecule.size, float)
            for i, number_i in enumerate(molecule.numbers):
                if number_i < 3:
                    self.noble_radii[i] = 0.2
                else:
                    densities = self.atgrids[i].moldens
                    radfun = integrate_lebedev(self.context.lebedev_weights, densities)
                    rs = self.get_rs(i, number_i)
                    charge_int = cumul_integrate_log(rs, radfun*rs**2)
                    j = charge_int.searchsorted([core_sizes[number_i]])[0]
                    self.noble_radii[i] = rs[j]
            self.noble_radii.tofile(noble_radii_fn_bin)

    @OnlyOnce("Computing the ESP cost function")
    def do_esp_costfunction(self):
        # TODO: the ESP cost function should be upgraded to a more reliable
        # implementation. We should consider the cost function as an integral
        # over the volume where the density is not too high and the distance
        # from the molecule is not too far. This can be achieved by a
        # combination of Becke's integration scheme
        # (http://dx.doi.org/10.1063/1.454033) and Hu's ESP method
        # (http://dx.doi.org/10.1021/ct600295n). Then there is no need to
        # construct a molecular grid. The atomic grids are sufficient.
        # TODO: output ESP charges in the same way as the stockholder charges.
        self.do_molgrid_moldens()
        self.do_molgrid_molpot()

        total_charge = self.context.wavefn.charge
        coordinates = self.context.wavefn.molecule.coordinates
        self.mol_esp_cost = ESPCostFunction(
            coordinates, self.molgrid.points, self.molgrid.weights,
            self.molgrid.moldens, self.molgrid.molpot, total_charge,
        )
        outfn = os.path.join(self.context.outdir, "mol_esp_cost.txt")
        self.mol_esp_cost.write_to_file(outfn)
        log("Written %s" % outfn)

    @OnlyOnce("Molecular grid")
    def do_molgrid(self):
        lebedev_xyz, lebedev_weights = get_grid(self.context.options.mol_lebedev)
        molecule = self.context.wavefn.molecule
        workdir = self.context.workdir

        prefix = os.path.join(workdir, "molecule")
        self.do_noble_radii()

        self.molgrid = Grid.from_prefix(prefix)
        if self.molgrid is not None:
            self.molgrid.weights = self.molgrid.load("weights")
        else:
            # we have to generate a new grid. The grid is constructed taking
            # into account the following considerations:
            # 1) Grid points within the cusp region are discarded
            # 2) The rest of the molecular and surrounding volume is sampled
            #    with spherical grids centered on the atoms. Around each atom,
            #    'scale_steps' of shells are placed with lebedev grid points
            #    (num_lebedev). The lebedev weights are used in the fit to
            #    avoid preferential directions within one shell.
            # 3) The radii of the shells start from scale_min*(cusp_radius+0.2)
            #    and go up to scale_max*(cusp_radius+0.2).
            # 4) Each shell will be randomly rotated around the atom to avoid
            #    global preferential directions in the grid.
            # 5) The default parameters for the grid should be sufficient for
            #    sane ESP fitting. The ESP cost function should discard points
            #    with a density larger than a threshold, i.e. 1e-5 a.u. A
            #    gradual transition between included and discarded points around
            #    this threshold will improve the quality of the fit.

            scale_min = 1.5
            scale_max = 30.0
            scale_steps = 30
            scale_factor = (scale_max/scale_min)**(1.0/(scale_steps-1))
            scales = scale_min*scale_factor**numpy.arange(scale_steps)

            points = []
            weights = []
            pb = log.pb("Constructing molecular grid", scale_steps)
            for scale in scales:
                pb()
                radii = scale*self.noble_radii
                for i in xrange(molecule.size):
                    rot = Rotation.random()
                    for j in xrange(len(lebedev_xyz)):
                        my_point = radii[i]*numpy.dot(rot.r, lebedev_xyz[j]) + molecule.coordinates[i]
                        distances = numpy.sqrt(((molecule.coordinates - my_point)**2).sum(axis=1))
                        if (distances < scales[0]*self.noble_radii).any():
                            continue
                        points.append(my_point)
                        weights.append(lebedev_weights[j])
            pb()
            points = numpy.array(points)
            weights = numpy.array(weights)

            self.molgrid = Grid(prefix, points)
            self.molgrid.weights = weights
            self.molgrid.dump("weights", weights)

    @OnlyOnce("Molecular density on the molecular grid")
    def do_molgrid_moldens(self):
        self.do_molgrid()
        self.context.wavefn.compute_density(self.molgrid)

    @OnlyOnce("Molecular potential on the molecular grid")
    def do_molgrid_molpot(self):
        self.do_molgrid()
        self.context.wavefn.compute_potential(self.molgrid)

    @OnlyOnce("Defining atomic weight functions (each on their own atomic grid)")
    def do_atgrids_atweights(self):
        log("Trying to load weight functions")
        success = self._load_atgrid_atweights()
        if not success:
            log("Could not load all weights functions from workdir. Computing them...")
            self._compute_atgrid_atweights()
            log("Writing results to workdir")
            self._dump_atgrid_atweights()

    def _load_atgrid_atweights(self):
        molecule = self.context.wavefn.molecule

        ws = []
        for i in xrange(molecule.size):
            w = self.atgrids[i].load("%s_atweights" % self.prefix)
            if w is None:
                return False
            else:
                ws.append(w)

        for i in xrange(molecule.size):
            self.atgrids[i].atweights = ws[i]
        return True

    def _compute_atgrid_atweights(self):
        raise NotImplementedError

    def _dump_atgrid_atweights(self):
        molecule = self.context.wavefn.molecule
        for i in xrange(molecule.size):
            self.atgrids[i].dump("%s_atweights" % self.prefix, self.atgrids[i].atweights)

    @OnlyOnce("Atomic charges")
    def do_charges(self):
        self.do_esp_costfunction()
        charges_fn_bin = os.path.join(self.context.workdir, "%s_charges.bin" % self.prefix)
        populations_fn_bin = os.path.join(self.context.workdir, "%s_populations.bin" % self.prefix)
        molecule = self.context.wavefn.molecule

        if os.path.isfile(charges_fn_bin) and os.path.isfile(populations_fn_bin):
            log("Loading charges.")
            self.charges = numpy.fromfile(charges_fn_bin, float)
            self.populations = numpy.fromfile(populations_fn_bin, float)
        else:
            self.do_atgrids()
            self.do_atgrids_moldens()
            self.do_atgrids_atweights()

            pb = log.pb("Computing charges", molecule.size)
            self.populations = numpy.zeros(molecule.size, float)
            self.charges = numpy.zeros(molecule.size, float)
            for i, number_i in enumerate(molecule.numbers):
                pb()
                w = self.atgrids[i].atweights
                d = self.atgrids[i].moldens
                center = molecule.coordinates[i]

                integrand = d*w
                radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                rs = self.get_rs(i, number_i)
                self.populations[i] = integrate_log(rs, radfun*rs**2)
                self.charges[i] = number_i - self.populations[i]
            pb()
            self.populations.tofile(populations_fn_bin)
            if self.context.options.fix_total_charge:
                log("Ugly step: Adding constant to charges so that the total charge is zero.")
                self.charges -= (self.charges.sum() - self.context.wavefn.charge)/molecule.size
            self.charges.tofile(charges_fn_bin)

        # now some nice output
        def output(filename, charges, esp_cost):
            filename = os.path.join(self.context.outdir, filename)
            f = file(filename, "w")
            print >> f, "number of atoms:", molecule.size
            print >> f, "  i        Z      Charge"
            print >> f, "-----------------------------"
            for i, number in enumerate(molecule.numbers):
                print >> f, "% 3i  %2s  % 3i   % 10.5f" % (
                    i+1, periodic[number].symbol, number, charges[i]
                )
            print >> f, "-----------------------------"
            print >> f, "   Q SUM       % 10.5f" % charges.sum()
            print >> f, "   Q RMS       % 10.5f" % numpy.sqrt((charges**2).mean())
            print >> f, " ESP RMS         % 10.5e" % esp_cost.rms
            print >> f, "ESP RMSD         % 10.5e" % esp_cost.rmsd(charges)
            print >> f
            f.close()
            log("Written %s" % filename)

        output("%s_charges.txt" % self.prefix, self.charges, self.mol_esp_cost)

    @OnlyOnce("Atomic dipoles")
    def do_dipoles(self):
        self.do_esp_costfunction()
        self.do_charges()
        dipoles_fn_bin = os.path.join(self.context.workdir, "%s_dipoles.bin" % self.prefix)
        molecule = self.context.wavefn.molecule

        if os.path.isfile(dipoles_fn_bin):
            log("Loading dipoles.")
            self.dipoles = numpy.fromfile(dipoles_fn_bin, float).reshape((-1,3))
        else:
            self.do_atgrids()
            self.do_atgrids_moldens()
            self.do_atgrids_atweights()

            pb = log.pb("Computing dipoles", molecule.size)
            self.dipoles = numpy.zeros((molecule.size,3), float)
            for i, number_i in enumerate(molecule.numbers):
                pb()
                atgrid = self.atgrids[i]
                w = atgrid.atweights
                d = atgrid.moldens
                center = molecule.coordinates[i]

                for j in 0,1,2:
                    integrand = -(atgrid.points[:,j] - center[j])*d*w
                    radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                    rs = self.get_rs(i, number_i)
                    self.dipoles[i,j] = integrate_log(rs, radfun*rs**2)
            pb()
            self.dipoles.tofile(dipoles_fn_bin)

        # now some nice output
        def output(filename, charges, dipoles, esp_cost, dipole_qm):
            filename = os.path.join(self.context.outdir, filename)
            f = file(filename, "w")
            print >> f, "number of atoms:", molecule.size
            print >> f, "  i        Z     Dipole-X     Dipole-Y     Dipole-Z      Dipole"
            print >> f, "------------------------------------------------------------------"
            for i, number in enumerate(molecule.numbers):
                print >> f, "% 3i  %2s  % 3i   % 10.5f   % 10.5f   % 10.5f   % 10.5f" % (
                    i+1, periodic[number].symbol, number, dipoles[i,0],
                    dipoles[i,1], dipoles[i,2], numpy.linalg.norm(dipoles[i]),
                )
            print >> f, "------------------------------------------------------------------"

            dipole_q = (molecule.coordinates*charges.reshape((-1,1))).sum(axis=0)
            dipole_p = dipoles.sum(axis=0)
            dipole_qp = dipole_q + dipole_p
            print >> f, "Molecular dipole due to ..."
            print >> f, "charges (q)    % 10.5f   % 10.5f   % 10.5f   % 10.5f" % (
                dipole_q[0], dipole_q[1], dipole_q[2], numpy.linalg.norm(dipole_q),
            )
            print >> f, "dipoles (p)    % 10.5f   % 10.5f   % 10.5f   % 10.5f" % (
                dipole_p[0], dipole_p[1], dipole_p[2], numpy.linalg.norm(dipole_p),
            )
            print >> f, "q and p        % 10.5f   % 10.5f   % 10.5f   % 10.5f" % (
                dipole_qp[0], dipole_qp[1], dipole_qp[2], numpy.linalg.norm(dipole_qp),
            )
            print >> f, "total density  % 10.5f   % 10.5f   % 10.5f   % 10.5f" % (
                dipole_qm[0], dipole_qm[1], dipole_qm[2], numpy.linalg.norm(dipole_qm),
            )
            print >> f, "------------------------------------------------------------------"

            print >> f, "Reproduction of the external molecular ESP ..."
            print >> f, "                     RMSD             RMS       CORRELATION"
            print >> f, "charges (q)      % 10.5e    % 10.5e      % 5.2f" % (
                esp_cost.rmsd(charges),
                esp_cost.model_rms(charges),
                esp_cost.correlation(charges),
            )
            print >> f, "dipoles (p)      % 10.5e    % 10.5e      % 5.2f" % (
                esp_cost.rmsd(None, dipoles),
                esp_cost.model_rms(None, dipoles),
                esp_cost.correlation(None, dipoles),
            )
            print >> f, "q and p          % 10.5e    % 10.5e      % 5.2f" % (
                esp_cost.rmsd(charges, dipoles),
                esp_cost.model_rms(charges, dipoles),
                esp_cost.correlation(charges, dipoles),
            )
            print >> f, "total density                    % 10.5e" % esp_cost.rms
            f.close()
            log("Written %s" % filename)

        dipole_qm = self.context.wavefn.dipole
        output(
            "%s_dipoles.txt" % self.prefix, self.charges, self.
            dipoles, self.mol_esp_cost, dipole_qm
        )

    @OnlyOnce("Evaluating orbitals on atomic grids")
    def do_atgrids_orbitals(self):
        log("Warning: Only using alpha orbitals. Assuming restricted orbitals.")

        self.do_atgrids()
        molecule = self.context.wavefn.molecule
        num_orbitals = self.context.wavefn.num_orbitals
        workdir = self.context.workdir

        pb = log.pb("Computing/Loading orbitals", molecule.size)
        for i, number_i in enumerate(molecule.numbers):
            self.context.wavefn.compute_orbitals(self.atgrids[i])
        pb()

    @OnlyOnce("Partitioning the density matrix")
    def do_atgrids_atdm(self):
        self.do_atgrids_orbitals()
        self.do_atgrids_atweights()
        num_orbitals = self.context.wavefn.num_orbitals
        molecule = self.context.wavefn.molecule

        pb = log.pb("Computing matrices", molecule.size)
        for i, number_i in enumerate(molecule.numbers):
            pb()
            orbitals = self.atgrids[i].orbitals
            w = self.atgrids[i].atweights
            matrix = numpy.zeros((num_orbitals,num_orbitals), float)
            rs = self.get_rs(i, number_i)
            for j1 in xrange(num_orbitals):
                for j2 in xrange(j1+1):
                    integrand = orbitals[j1]*orbitals[j2]*w
                    radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                    value = integrate_log(rs, radfun*rs**2)
                    matrix[j1,j2] = value
                    matrix[j2,j1] = value
            self.atgrids[i].atdm = matrix
        pb()

        filename = os.path.join(self.context.outdir, "%s_atdm.txt" % self.prefix)
        f = file(filename, "w")
        print >> f, "number of orbitals:", num_orbitals
        print >> f, "number of atoms: ", molecule.size
        for i, number_i in enumerate(molecule.numbers):
            print >> f, "Atom %i: %s" % (i, periodic[number_i].symbol)
            for row in self.atgrids[i].atdm:
                print >> f, " ".join("% 15.10e" % value for value in row)
        f.close()
        log("Written %s" % filename)

    @OnlyOnce("Bond orders and atomic valences")
    def do_bond_orders(self):
        self.do_charges()
        self.do_atgrids_atdm()

        molecule = self.context.wavefn.molecule
        self.bond_orders = numpy.zeros((molecule.size, molecule.size))
        self.valences = numpy.zeros(molecule.size)
        num_orbitals = self.context.wavefn.num_orbitals
        n_alpha = self.context.wavefn.num_alpha
        n_beta = self.context.wavefn.num_beta
        n_min = min(n_alpha, n_beta)
        n_max = max(n_alpha, n_beta)

        pb = log.pb("Computing bond orders", (molecule.size*(molecule.size+1))/2)
        check = 0
        for i in xrange(molecule.size):
            for j in xrange(i+1):
                tmp = self.atgrids[i].atdm[:n_max,:n_max]*self.atgrids[j].atdm[:n_max,:n_max]
                check += tmp
                tmp[:n_min,:] *= 2
                tmp[:,:n_min] *= 2
                bo = tmp.sum()
                pb()
                if i==j:
                    # compute valence
                    self.valences[i] = 2*self.populations[i] - bo
                else:
                    # compute bond order
                    self.bond_orders[i,j] = bo
                    self.bond_orders[j,i] = bo
        pb()

        filename = os.path.join(self.context.outdir, "%s_bond_orders.txt" % self.prefix)
        f = file(filename, "w")
        print >> f, "number of atoms: ", molecule.size
        print >> f, "Bond orders"
        for i in xrange(molecule.size):
            print >> f, " ".join("%15.9f" % v for v in self.bond_orders[i])
        print >> f, "Valences, Free valences"
        for i in xrange(molecule.size):
            print >> f, "%15.9f" % self.valences[i], "%15.9f" % (self.valences[i] - self.bond_orders[i].sum())
        f.close()
        log("Written %s" % filename)

    @OnlyOnce("Atomic weights on other atoms' grids.")
    def do_atgrids_od_atweights(self):
        # od stands for off-diagonal
        self.do_atgrids_atweights()

        molecule = self.context.wavefn.molecule
        pb = log.pb("Computing weights", molecule.size**2)
        for i in xrange(molecule.size):
            atgrid = self.atgrids[i]
            atgrid.od_atweights = []
            for j in xrange(molecule.size):
                pb()
                w = self._compute_atweights(atgrid, j)
                atgrid.od_atweights.append(w)
        pb()

    def _compute_atweights(self, grid, atom_index):
        raise NotImplementedError

    @OnlyOnce("Overlap populations")
    def do_overlap_populations(self):
        overlap_populations_fn_bin = os.path.join(self.context.workdir, "%s_overlap_populations.bin" % self.prefix)
        molecule = self.context.wavefn.molecule

        if os.path.isfile(overlap_populations_fn_bin):
            log("Loading overlap populations.")
            self.overlap_populations = numpy.fromfile(overlap_populations_fn_bin, float).reshape((molecule.size,molecule.size))
        else:
            self.do_atgrids()
            self.do_atgrids_moldens()
            self.do_charges()
            self.do_atgrids_od_atweights()
            self.overlap_populations = numpy.zeros((molecule.size, molecule.size))
            pb = log.pb("Integrating over products of stockholder weights", (molecule.size*(molecule.size+1))/2)
            for i, number_i in enumerate(molecule.numbers):
                for j, number_j in enumerate(molecule.numbers[:i+1]):
                    pb()
                    if i != j:
                        # Use Becke's integration scheme to split the integral
                        # over two atomic grids.
                        # 1) first part of the integral, using the grid on atom i
                        rs = self.get_rs(i, number_i)
                        delta = (self.atgrids[i].distances[j].reshape((len(rs),-1)) - rs.reshape((-1,1))).ravel()
                        switch = delta/molecule.distance_matrix[i,j]
                        for k in xrange(3):
                            switch = (3 - switch**2)*switch/2
                        switch += 1
                        switch /= 2
                        integrand = switch*self.atgrids[i].od_atweights[j]*self.atgrids[i].atweights*self.atgrids[i].moldens
                        radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                        part1 = integrate_log(rs, radfun*rs**2)
                        # 2) second part of the integral
                        rs = self.get_rs(j, number_j)
                        delta = (self.atgrids[j].distances[i].reshape((len(rs),-1)) - rs.reshape((-1,1))).ravel()
                        switch = delta/molecule.distance_matrix[i,j]
                        for k in xrange(3):
                            switch = (3 - switch**2)*switch/2
                        switch += 1
                        switch /= 2
                        integrand = switch*self.atgrids[j].od_atweights[i]*self.atgrids[j].atweights*self.atgrids[j].moldens
                        radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                        part2 = integrate_log(rs, radfun*rs**2)
                        # Add up and store
                        self.overlap_populations[i,j] = part1 + part2
                        self.overlap_populations[j,i] = part1 + part2
                    else:
                        integrand = self.atgrids[i].atweights**2*self.atgrids[i].moldens
                        radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                        rs = self.get_rs(i, number_i)
                        self.overlap_populations[i,i] = integrate_log(rs, radfun*rs**2)
            pb()
            self.overlap_populations.tofile(overlap_populations_fn_bin)

        def output(filename, overlap_populations):
            # print a file with the overlap populations
            filename = os.path.join(self.context.outdir, filename)
            f = file(filename, "w")
            print >> f, "number of atoms:", molecule.size
            for i in xrange(molecule.size):
                print >> f, " ".join("%15.9f" % v for v in overlap_populations[i])
            f.close()
            log("Written %s" % filename)

        output("%s_overlap_populations.txt" % self.prefix, self.overlap_populations)


class StockholderCache(BaseCache):
    def do_proatomfns(self):
        raise NotImplementedError

    def _compute_atgrid_atweights(self):
        self.do_proatomfns()
        molecule = self.context.wavefn.molecule
        for i in xrange(molecule.size):
            self.atgrids[i].atweights = self._compute_atweights(
                self.atgrids[i], i
            )

    def _compute_atweights(self, grid, atom_index):
        """Return the weight of atom with given index in the given grid points
        """
        molecule = self.context.wavefn.molecule
        # construct the pro-atom and pro-molecule on this grid
        pro_atom = self.proatomfns[atom_index].density(grid.distances[atom_index])
        pro_mol = numpy.zeros(len(pro_atom), float)
        for j in xrange(molecule.size):
            pro_mol += self.proatomfns[j].density(grid.distances[j])
        # multiply the density on the grid by the weight function
        return pro_atom/pro_mol


class TableBaseCache(StockholderCache):
    @classmethod
    def new_from_args(cls, context, args):
        if len(args) == 1:
            atom_table = AtomTable(args[0])
        else:
            raise ParseError("The Hirshfeld schemes require one scheme argument.")
        return cls(context, atom_table)

    def __init__(self, context, atom_table, prefix):
        self.atom_table = atom_table
        BaseCache.__init__(self, context, prefix)
        # write the rs to the workdir for plotting purposes:
        atom_table.rs.tofile(os.path.join(self.context.workdir, "rs.bin"))

    def get_rs(self, i, number_i):
        if number_i == 0:
            return self.atom_table.rs
        else:
            return self.atom_table.records[number_i].rs


hirshfeld_usage = """ * Hirshfeld Partitioning
     scheme = hirsh
     scheme parameters = densities.txt

     The file densities.txt is generated with the script hi-atomdb.py. It
     cotains spherically averaged densities of individual atoms. Make sure all
     the atoms present in the molecule of interest are included in the file
     densities.txt

     Hirshfeld, F. L. Theor. Chim. Acta 1977, 44, 129-138.
     http://dx.doi.org/10.1007/BF00549096
"""

class HirshfeldCache(TableBaseCache):
    key = "hirsh"
    usage = hirshfeld_usage

    def __init__(self, context, atom_table):
        TableBaseCache.__init__(self, context, atom_table, "hirsh")

    @OnlyOnce("Conventional Hirshfeld (with neutral pro-atoms)")
    def do_proatomfns(self):
        self.do_atgrids()
        molecule = self.context.wavefn.molecule
        self.proatomfns = []
        for i, number_i in enumerate(molecule.numbers):
            self.proatomfns.append(self.atom_table.records[number_i].get_atom_fn(0.0))


hirshfeld_i_usage = """ * Hirshfeld-I Partitioning
     scheme = hirshi
     scheme parameters = densities.txt

     The file densities.txt is generated with the script hi-atomdb.py. It
     cotains spherically averaged densities of individual atoms. Make sure all
     the atoms present in the molecule of interest are included in the file
     densities.txt

     Bultinck, P.;  Van Alsenoy, C.;  Ayers, P. W.;  Dorca, R. C. J. Chem. Phys.
     2007, 126, 144111.
     http://dx.doi.org/10.1063/1.2715563
"""

class HirshfeldICache(TableBaseCache):
    key = "hirshi"
    usage = hirshfeld_i_usage

    def __init__(self, context, atom_table):
        TableBaseCache.__init__(self, context, atom_table, "hirshi")

    @OnlyOnce("Iterative Hirshfeld")
    def do_proatomfns(self):
        molecule = self.context.wavefn.molecule
        self.do_atgrids_moldens()

        counter = 0
        old_charges = numpy.zeros(molecule.size, float)
        while True:
            # construct the pro-atom density functions, using the densities
            # from the previous iteration.
            self.proatomfns = []
            for i, number_i in enumerate(molecule.numbers):
                self.proatomfns.append(self.atom_table.records[number_i].get_atom_fn(old_charges[i]))

            charges = []
            for i, number_i in enumerate(molecule.numbers):
                fn = self.atgrids[i].moldens*self._compute_atweights(self.atgrids[i], i)
                radfun = integrate_lebedev(self.context.lebedev_weights, fn)
                rs = self.atom_table.records[number_i].rs
                num_electrons = integrate_log(rs, radfun*rs**2)
                charges.append(number_i - num_electrons)

            # ordinary blablabla ...
            charges = numpy.array(charges)
            max_change = abs(charges-old_charges).max()
            log("Iteration %03i    max change = %10.5e    total charge = %10.5e" % (
                counter, max_change, charges.sum()
            ))
            if max_change < self.context.options.threshold:
                break
            counter += 1
            if counter > self.context.options.max_iter:
                raise RuntimeError("Iterative Hirshfeld failed to converge.")
            old_charges = charges


isa_usage = """ * Iterative Stockholder Partitioning
     scheme = isa
     scheme parameters = [r_low r_high steps]

     Three additional parameters must be provided of the file rs.bin is not yet
     present in the work directory. The first two, r_low and r_high, are the
     first and the last point on the logarithmic radial grid in angstrom. The
     third, steps, is the number of grid points on the radial grid.

     This scheme has no parameters.

     Lillestolen, T. C.;  Wheatley, R. J. Chem. Commun. 2008,  5909-5911.
     http://dx.doi.org/10.1039/b812691g
"""

class ISACache(StockholderCache):
    key = "isa"
    usage = isa_usage

    @classmethod
    def new_from_args(cls, context, args):
        if len(args) == 3:
            r_low = float(args[0])*angstrom
            r_high = float(args[1])*angstrom
            steps = float(args[2])
            ratio = (r_high/r_low)**(1.0/(steps-1))
            alpha = numpy.log(ratio)
            rs = r_low*numpy.exp(alpha*numpy.arange(0,steps))
        elif len(args) == 0:
            rs_fn_bin = os.path.join(context.workdir, "rs.bin")
            if os.path.isfile(rs_fn_bin):
                rs = numpy.fromfile(rs_fn_bin)
            else:
                raise ParseError("When no scheme arguments are given for the ISA scheme, the file rs.bin must exist in the workdir.")
        else:
            raise ParseError("The ISA scheme requires zero or three scheme arguments.")
        return cls(context, rs)

    def __init__(self, context, rs):
        self.rs = rs
        BaseCache.__init__(self, context, "isa")
        # write the rs to the workdir for plotting purposes:
        self.rs.tofile(os.path.join(self.context.workdir, "rs.bin"))

    def get_rs(self, i, number_i):
        if number_i == 0:
            return self.rs
        elif hasattr(self, "proatomfns") and len(self.proatomfns) > i:
            return self.proatomfns[i].density.x
        elif hasattr(self, "atgrids") and len(self.atgrids) > i:
            num_shells = len(self.atgrids[i].moldens)/self.context.num_lebedev
            return self.rs[:num_shells]
        else:
            return self.rs

    @OnlyOnce("Iterative Stockholder Analysis")
    def do_proatomfns(self):
        molecule = self.context.wavefn.molecule
        self.do_atgrids_moldens()

        log("Generating initial guess for the pro-atoms")
        self.proatomfns = []
        for i, number_i in enumerate(molecule.numbers):
            densities = self.atgrids[i].moldens
            profile = densities.reshape((-1,self.context.num_lebedev)).min(axis=1)
            profile[profile < 1e-6] = 1e-6
            rs = self.get_rs(i, number_i)
            self.proatomfns.append(AtomFn(rs, profile))

        counter = 0
        old_charges = numpy.zeros(molecule.size, float)
        while True:
            new_proatomfns = []
            charges = []
            for i, number_i in enumerate(molecule.numbers):
                fn = self.atgrids[i].moldens*self._compute_atweights(self.atgrids[i], i)
                radfun = integrate_lebedev(self.context.lebedev_weights, fn)
                rs = self.get_rs(i, number_i)
                num_electrons = integrate_log(rs, radfun*rs**2)
                charges.append(number_i - num_electrons)
                # add negligible tails to maintain a complete partitioning
                radfun[radfun < 1e-40] = 1e-40
                new_proatomfn = AtomFn(rs, radfun/4*numpy.pi)
                new_proatomfns.append(new_proatomfn)

            # ordinary blablabla ...
            charges = numpy.array(charges)
            max_change = abs(charges-old_charges).max()
            log("Iteration %03i    max change = %10.5e    total charge = %10.5e" % (
                counter, max_change, charges.sum()
            ))
            if max_change < self.context.options.threshold:
                break
            counter += 1
            if counter > self.context.options.max_iter:
                raise RuntimeError("Iterative Stockholder Analysis failed to converge.")
            old_charges = charges
            self.proatomfns = new_proatomfns


# find all usable Cache classes
cache_classes = {}
for x in globals().values():
    if isinstance(x, type) and issubclass(x, BaseCache) and x.key is not None:
        cache_classes[x.key] = x
