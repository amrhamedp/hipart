# HiPart is a software toolkit to analyse molecular densities with the hirshfeld partitioning scheme.
# Copyright (C) 2007 - 2010 Toon Verstraelen <Toon.Verstraelen@UGent.be>
#
# This file is part of HiPart.
#
# HiPart is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# HiPart is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>
#
# --


# TODO: fix free valence in non-closed-shell systems
# TODO: Support for Gaussian/GAMESS wfn files.
# TODO: Extend hi-atomdb.py to work with GAMESS
# TODO: Implement Becke's scheme as one of the population schemes.
# TODO: Implement the potential generated by an atomic density, and evaluate it
# on grids of other atoms. This can be used to compute QM-level electrostatic
# interaction energies. (See Becke's paper )
# TODO: Compute condensed linear response properties
# TODO: Support for CP2K and CPMD wavefunctions
# TODO: Visualize Atomic devations from sphericallity (1D plots)
# TODO: Visualization of atomic (pair) data with graphs
# TODO: Cube files with atomic weights and densities


from hipart.log import log
from hipart.tools import get_atom_grid, dump_atom_scalars, dump_atom_vectors, \
    dump_atom_matrix, dump_atom_fields
from hipart.integrate import cumul_integrate_log, integrate_log, \
    integrate_lebedev
from hipart.fit import ESPCostFunction
from hipart.lebedev_laikov import get_grid
from hipart.atoms import AtomTable, AtomFn
from hipart.grids import Grid

from molmod import Rotation, angstrom
from molmod.periodic import periodic

import os, numpy


__all__ = ["ComputeError", "ParseError", "cache_classes"]


noble_numbers = numpy.array([0,2,10,18,36,54,86,118])
core_sizes = dict((number, noble_numbers[noble_numbers<=number].max()) for number in periodic.iter_numbers())


class ComputeError(Exception):
    pass

class ParseError(Exception):
    pass


class OnlyOnce(object):
    def __init__(self, description):
        self.description = description

    def __call__(self, fn):
        def wrapper(instance):
            if fn.func_name in instance._done:
                return
            log.begin(self.description)
            fn(instance)
            log.end(self.description)
            instance._done.add(fn.func_name)
        wrapper.__doc__ = fn.__doc__
        return wrapper


class BaseCache(object):
    key = None
    usage = None

    @classmethod
    def new_from_args(cls, context, args):
        raise NotImplementedError

    def __init__(self, context, prefix):
        self.prefix = prefix
        self.context = context
        self.context.check_tag(self.get_rs(0,0))
        self._done = set([])

    def get_rs(self, i, number_i):
        raise NotImplementedError

    @OnlyOnce("Atomic grids")
    def do_atgrids(self):
        molecule = self.context.wavefn.molecule
        workdir = self.context.workdir

        self.atgrids = []
        pb = log.pb("Computing/Loading atomic grids (and distances)", molecule.size**2)
        for i, number_i in enumerate(molecule.numbers):
            prefix = os.path.join(workdir, "atom%05i" % i)
            atgrid = Grid.from_prefix(prefix)
            if atgrid is None:
                center = molecule.coordinates[i]
                points = get_atom_grid(
                    self.context.lebedev_xyz, center,
                    self.get_rs(i, number_i),
                )
                atgrid = Grid(prefix, points)
            self.atgrids.append(atgrid)

            # Compute and store all the distances from these grid points to the
            # nuclei.
            atgrid.distances = []
            for j, number_j in enumerate(molecule.numbers):
                pb()
                distances = numpy.sqrt(((atgrid.points - molecule.coordinates[j])**2).sum(axis=1))
                # distances from grid points of atom i to atom j.
                atgrid.distances.append(distances)
        pb()

    @OnlyOnce("Molecular density on atomic grids")
    def do_atgrids_moldens(self):
        self.do_atgrids()
        molecule = self.context.wavefn.molecule
        pb = log.pb("Computing/Loading densities", molecule.size)
        for i, number_i in enumerate(molecule.numbers):
            pb()
            self.context.wavefn.compute_density(self.atgrids[i])
        pb()

    @OnlyOnce("Molecular spin density on atomic grids")
    def do_atgrids_molspindens(self):
        self.do_atgrids()
        molecule = self.context.wavefn.molecule
        pb = log.pb("Computing/Loading spin densities", molecule.size)
        for i, number_i in enumerate(molecule.numbers):
            pb()
            self.context.wavefn.compute_spin_density(self.atgrids[i])
        pb()

    @OnlyOnce("Estimating noble gas core radii")
    def do_noble_radii(self):
        molecule = self.context.wavefn.molecule
        workdir = self.context.workdir

        noble_radii_fn_bin = os.path.join(workdir, "noble_radii.bin")
        if os.path.isfile(noble_radii_fn_bin):
            log("Loading noble radii")
            self.noble_radii = numpy.fromfile(noble_radii_fn_bin, float)
        else:
            self.do_atgrids_moldens()
            log("Computing noble radii")
            self.noble_radii = numpy.zeros(molecule.size, float)
            for i, number_i in enumerate(molecule.numbers):
                if number_i < 3:
                    self.noble_radii[i] = 0.2
                else:
                    densities = self.atgrids[i].moldens
                    radfun = integrate_lebedev(self.context.lebedev_weights, densities)
                    rs = self.get_rs(i, number_i)
                    charge_int = cumul_integrate_log(rs, radfun*rs**2)
                    j = charge_int.searchsorted([core_sizes[number_i]])[0]
                    self.noble_radii[i] = rs[j]
            self.noble_radii.tofile(noble_radii_fn_bin)

    @OnlyOnce("Computing the ESP cost function")
    def do_esp_costfunction(self):
        # TODO: the ESP cost function should be upgraded to a more reliable
        # implementation. We should consider the cost function as an integral
        # over the volume where the density is not too high and the distance
        # from the molecule is not too far. This can be achieved by a
        # combination of Becke's integration scheme
        # (http://dx.doi.org/10.1063/1.454033) and Hu's ESP method
        # (http://dx.doi.org/10.1021/ct600295n). Then there is no need to
        # construct a molecular grid. The atomic grids are sufficient.
        # TODO: output ESP charges in the same way as the stockholder charges.
        self.do_molgrid_moldens()
        self.do_molgrid_molpot()

        total_charge = self.context.wavefn.charge
        coordinates = self.context.wavefn.molecule.coordinates
        self.mol_esp_cost = ESPCostFunction(
            coordinates, self.molgrid.points, self.molgrid.weights,
            self.molgrid.moldens, self.molgrid.molpot, total_charge,
        )
        outfn = os.path.join(self.context.outdir, "mol_esp_cost.txt")
        self.mol_esp_cost.write_to_file(outfn)
        log("Written %s" % outfn)

    @OnlyOnce("Molecular grid")
    def do_molgrid(self):
        lebedev_xyz, lebedev_weights = get_grid(self.context.options.mol_lebedev)
        molecule = self.context.wavefn.molecule
        workdir = self.context.workdir

        prefix = os.path.join(workdir, "molecule")
        self.do_noble_radii()

        self.molgrid = Grid.from_prefix(prefix)
        if self.molgrid is not None:
            self.molgrid.weights = self.molgrid.load("weights")
        else:
            # we have to generate a new grid. The grid is constructed taking
            # into account the following considerations:
            # 1) Grid points within the cusp region are discarded
            # 2) The rest of the molecular and surrounding volume is sampled
            #    with spherical grids centered on the atoms. Around each atom,
            #    'scale_steps' of shells are placed with lebedev grid points
            #    (num_lebedev). The lebedev weights are used in the fit to
            #    avoid preferential directions within one shell.
            # 3) The radii of the shells start from scale_min*(cusp_radius+0.2)
            #    and go up to scale_max*(cusp_radius+0.2).
            # 4) Each shell will be randomly rotated around the atom to avoid
            #    global preferential directions in the grid.
            # 5) The default parameters for the grid should be sufficient for
            #    sane ESP fitting. The ESP cost function should discard points
            #    with a density larger than a threshold, i.e. 1e-5 a.u. A
            #    gradual transition between included and discarded points around
            #    this threshold will improve the quality of the fit.

            scale_min = 1.5
            scale_max = 30.0
            scale_steps = 30
            scale_factor = (scale_max/scale_min)**(1.0/(scale_steps-1))
            scales = scale_min*scale_factor**numpy.arange(scale_steps)

            points = []
            weights = []
            pb = log.pb("Constructing molecular grid", scale_steps)
            for scale in scales:
                pb()
                radii = scale*self.noble_radii
                for i in xrange(molecule.size):
                    rot = Rotation.random()
                    for j in xrange(len(lebedev_xyz)):
                        my_point = radii[i]*numpy.dot(rot.r, lebedev_xyz[j]) + molecule.coordinates[i]
                        distances = numpy.sqrt(((molecule.coordinates - my_point)**2).sum(axis=1))
                        if (distances < scales[0]*self.noble_radii).any():
                            continue
                        points.append(my_point)
                        weights.append(lebedev_weights[j])
            pb()
            points = numpy.array(points)
            weights = numpy.array(weights)

            self.molgrid = Grid(prefix, points)
            self.molgrid.weights = weights
            self.molgrid.dump("weights", weights)

    @OnlyOnce("Molecular density on the molecular grid")
    def do_molgrid_moldens(self):
        self.do_molgrid()
        self.context.wavefn.compute_density(self.molgrid)

    @OnlyOnce("Molecular potential on the molecular grid")
    def do_molgrid_molpot(self):
        self.do_molgrid()
        log("This make take a minute. Hang on.")
        self.context.wavefn.compute_potential(self.molgrid)

    def _prepare_atweights(self):
        pass

    @OnlyOnce("Defining atomic weight functions (each on their own atomic grid)")
    def do_atgrids_atweights(self):
        log("Trying to load weight functions")
        success = self._load_atgrid_atweights()
        if not success:
            log("Could not load all weight functions from workdir. Computing them...")
            self._prepare_atweights()
            self._compute_atgrid_atweights()
            log("Writing results to workdir")
            self._dump_atgrid_atweights()

    def _load_atgrid_atweights(self):
        molecule = self.context.wavefn.molecule

        ws = []
        for i in xrange(molecule.size):
            w = self.atgrids[i].load("%s_atweights" % self.prefix)
            if w is None:
                return False
            else:
                ws.append(w)

        for i in xrange(molecule.size):
            self.atgrids[i].atweights = ws[i]
        return True

    def _compute_atgrid_atweights(self):
        raise NotImplementedError

    def _dump_atgrid_atweights(self):
        molecule = self.context.wavefn.molecule
        for i in xrange(molecule.size):
            self.atgrids[i].dump("%s_atweights" % self.prefix, self.atgrids[i].atweights)

    @OnlyOnce("Atomic charges")
    def do_charges(self):
        charges_fn_bin = os.path.join(self.context.workdir, "%s_charges.bin" % self.prefix)
        populations_fn_bin = os.path.join(self.context.workdir, "%s_populations.bin" % self.prefix)
        molecule = self.context.wavefn.molecule

        if os.path.isfile(charges_fn_bin) and os.path.isfile(populations_fn_bin):
            log("Loading charges.")
            self.charges = numpy.fromfile(charges_fn_bin, float)
            self.populations = numpy.fromfile(populations_fn_bin, float)
        else:
            self.do_atgrids()
            self.do_atgrids_moldens()
            self.do_atgrids_atweights()

            pb = log.pb("Computing charges", molecule.size)
            self.populations = numpy.zeros(molecule.size, float)
            self.charges = numpy.zeros(molecule.size, float)
            for i, number_i in enumerate(molecule.numbers):
                pb()
                w = self.atgrids[i].atweights
                d = self.atgrids[i].moldens
                center = molecule.coordinates[i]

                integrand = d*w
                radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                rs = self.get_rs(i, number_i)
                self.populations[i] = integrate_log(rs, radfun*rs**2)
                self.charges[i] = number_i - self.populations[i]
            pb()
            self.populations.tofile(populations_fn_bin)
            if self.context.options.fix_total_charge:
                log("Ugly step: Adding constant to charges so that the total charge is zero.")
                self.charges -= (self.charges.sum() - self.context.wavefn.charge)/molecule.size
            self.charges.tofile(charges_fn_bin)

        charges_fn = os.path.join(self.context.outdir, "%s_charges.txt" % self.prefix)
        dump_atom_scalars(charges_fn, self.charges, molecule.numbers)
        log("Written %s" % charges_fn)

    @OnlyOnce("Atomic spin charges")
    def do_spin_charges(self):
        spin_charges_fn_bin = os.path.join(self.context.workdir, "%s_spin_charges.bin" % self.prefix)
        molecule = self.context.wavefn.molecule

        if os.path.isfile(spin_charges_fn_bin):
            log("Loading spin charges.")
            self.spin_charges = numpy.fromfile(spin_charges_fn_bin, float)
        else:
            self.do_atgrids()
            self.do_atgrids_molspindens()
            self.do_atgrids_atweights()

            pb = log.pb("Computing spin charges", molecule.size)
            self.spin_charges = numpy.zeros(molecule.size, float)
            for i, number_i in enumerate(molecule.numbers):
                pb()
                w = self.atgrids[i].atweights
                d = self.atgrids[i].molspindens
                center = molecule.coordinates[i]

                integrand = d*w
                radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                rs = self.get_rs(i, number_i)
                self.spin_charges[i] = integrate_log(rs, radfun*rs**2)
            pb()
            self.spin_charges.tofile(spin_charges_fn_bin)

        spin_charges_fn = os.path.join(self.context.outdir, "%s_spin_charges.txt" % self.prefix)
        dump_atom_scalars(spin_charges_fn, self.spin_charges, molecule.numbers, name="Spin charge")
        log("Written %s" % spin_charges_fn)

    @OnlyOnce("Atomic dipoles")
    def do_dipoles(self):
        dipoles_fn_bin = os.path.join(self.context.workdir, "%s_dipoles.bin" % self.prefix)
        molecule = self.context.wavefn.molecule

        if os.path.isfile(dipoles_fn_bin):
            log("Loading dipoles.")
            self.dipoles = numpy.fromfile(dipoles_fn_bin, float).reshape((molecule.size,3))
        else:
            self.do_atgrids()
            self.do_atgrids_moldens()
            self.do_atgrids_atweights()

            pb = log.pb("Computing dipoles", molecule.size)
            self.dipoles = numpy.zeros((molecule.size,3), float)
            for i, number_i in enumerate(molecule.numbers):
                pb()
                atgrid = self.atgrids[i]
                w = atgrid.atweights
                d = atgrid.moldens
                center = molecule.coordinates[i]

                for j in 0,1,2:
                    integrand = -(atgrid.points[:,j] - center[j])*d*w
                    radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                    rs = self.get_rs(i, number_i)
                    self.dipoles[i,j] = integrate_log(rs, radfun*rs**2)
            pb()
            self.dipoles.tofile(dipoles_fn_bin)

        # now some nice output
        dipoles_fn = os.path.join(self.context.outdir, "%s_dipoles.txt" % self.prefix)
        dump_atom_vectors(dipoles_fn, self.dipoles, molecule.numbers)
        log("Written %s" % dipoles_fn)

    @OnlyOnce("Atomic multipoles (up to hexadecapols)")
    def do_multipoles(self):
        regular_solid_harmonics = [
            lambda x,y,z: 1.0, # (0,0)
            lambda x,y,z: z, # (1,0)
            lambda x,y,z: x, # (1,1+)
            lambda x,y,z: y, # (1,1-)
            lambda x,y,z: 1.0*z**2 - 0.5*x**2 - 0.5*y**2, # (2,0)
            lambda x,y,z: 1.7320508075688772935*x*z, # (2,1+)
            lambda x,y,z: 1.7320508075688772935*y*z, # (2,1-)
            lambda x,y,z: 0.86602540378443864676*x**2 - 0.86602540378443864676*y**2, # (2,2+)
            lambda x,y,z: 1.7320508075688772935*x*y, # (2,2-)
            lambda x,y,z: -1.5*z*x**2 - 1.5*z*y**2 + z**3, # (3,0)
            lambda x,y,z: 2.4494897427831780982*x*z**2 - 0.61237243569579452455*x*y**2 - 0.61237243569579452455*x**3, # (3,1+)
            lambda x,y,z: 2.4494897427831780982*y*z**2 - 0.61237243569579452455*y*x**2 - 0.61237243569579452455*y**3, # (3,1-)
            lambda x,y,z: 1.9364916731037084426*z*x**2 - 1.9364916731037084426*z*y**2, # (3,2+)
            lambda x,y,z: 3.8729833462074168852*x*y*z, # (3,2-)
            lambda x,y,z: -2.371708245126284499*x*y**2 + 0.790569415042094833*x**3, # (3,3+)
            lambda x,y,z: 2.371708245126284499*y*x**2 - 0.790569415042094833*y**3, # (3,3-)
            lambda x,y,z: 0.75*x**2*y**2 - 3.0*x**2*z**2 - 3.0*y**2*z**2 + z**4 + 0.375*x**4 + 0.375*y**4, # (4,0)
            lambda x,y,z: -2.371708245126284499*x*z*y**2 + 3.162277660168379332*x*z**3 - 2.371708245126284499*z*x**3, # (4,1+)
            lambda x,y,z: -2.371708245126284499*y*z*x**2 + 3.162277660168379332*y*z**3 - 2.371708245126284499*z*y**3, # (4,1-)
            lambda x,y,z: 3.3541019662496845446*x**2*z**2 - 3.3541019662496845446*y**2*z**2 + 0.5590169943749474241*y**4 - 0.5590169943749474241*x**4, # (4,2+)
            lambda x,y,z: 6.7082039324993690892*x*y*z**2 - 1.1180339887498948482*x*y**3 - 1.1180339887498948482*y*x**3, # (4,2-)
            lambda x,y,z: -6.2749501990055666098*x*z*y**2 + 2.0916500663351888699*z*x**3, # (4,3+)
            lambda x,y,z: 6.2749501990055666098*y*z*x**2 - 2.0916500663351888699*z*y**3, # (4,3-)
            lambda x,y,z: -4.4370598373247120319*x**2*y**2 + 0.73950997288745200532*x**4 + 0.73950997288745200532*y**4, # (4,4+)
            lambda x,y,z: 2.9580398915498080213*y*x**3 - 2.9580398915498080213*x*y**3, # (4,4-)
        ]
        labels = [
            '(0,0)', '(1,0)', '(1,1+)', '(1,1-)', '(2,0)', '(2,1+)', '(2,1-)',
            '(2,2+)', '(2,2-)', '(3,0)', '(3,1+)', '(3,1-)', '(3,2+)', '(3,2-)',
            '(3,3+)', '(3,3-)', '(4,0)', '(4,1+)', '(4,1-)', '(4,2+)', '(4,2-)',
            '(4,3+)', '(4,3-)', '(4,4+)', '(4,4-)'
        ]

        multipoles_fn_bin = os.path.join(self.context.workdir, "%s_multipoles.bin" % self.prefix)
        molecule = self.context.wavefn.molecule

        if os.path.isfile(multipoles_fn_bin):
            log("Loading multipoles.")
            num_polys = len(regular_solid_harmonics)
            self.multipoles = numpy.fromfile(multipoles_fn_bin, float).reshape((molecule.size,num_polys))
        else:
            self.do_atgrids()
            self.do_atgrids_moldens()
            self.do_atgrids_atweights()

            pb = log.pb("Computing multipoles", molecule.size)
            num_polys = len(regular_solid_harmonics)
            self.multipoles = numpy.zeros((molecule.size,num_polys), float)
            for i, number_i in enumerate(molecule.numbers):
                pb()
                atgrid = self.atgrids[i]
                w = atgrid.atweights
                d = atgrid.moldens
                center = molecule.coordinates[i]

                cx = atgrid.points[:,0] - center[0]
                cy = atgrid.points[:,1] - center[1]
                cz = atgrid.points[:,2] - center[2]
                for j in xrange(num_polys):
                    poly = regular_solid_harmonics[j]
                    integrand = -poly(cx,cy,cz)*d*w
                    radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                    rs = self.get_rs(i, number_i)
                    self.multipoles[i,j] = integrate_log(rs, radfun*rs**2)
                self.multipoles[i,0] += number_i
            pb()
            self.multipoles.tofile(multipoles_fn_bin)

        # now some nice output
        multipoles_fn = os.path.join(self.context.outdir, "%s_multipoles.txt" % self.prefix)
        dump_atom_fields(multipoles_fn, self.multipoles, labels, molecule.numbers, "Multipoles")
        log("Written %s" % multipoles_fn)


    @OnlyOnce("Testing charges and dipoles on ESP grid.")
    def do_esp_test(self):
        self.do_charges()
        self.do_dipoles()
        self.do_esp_costfunction()

        molecule = self.context.wavefn.molecule

        filename = os.path.join(self.context.outdir, "%s_esp_test.txt" % self.prefix)
        f = file(filename, "w")
        print >> f, "                 Dipole-X     Dipole-Y     Dipole-Z      Dipole"
        print >> f, "------------------------------------------------------------------"
        dipole_q = (molecule.coordinates*self.charges.reshape((-1,1))).sum(axis=0)
        dipole_p = self.dipoles.sum(axis=0)
        dipole_qp = dipole_q + dipole_p
        dipole_qm = self.context.wavefn.dipole
        print >> f, "Molecular dipole due to ..."
        print >> f, "charges (q)    % 10.5f   % 10.5f   % 10.5f   % 10.5f" % (
            dipole_q[0], dipole_q[1], dipole_q[2], numpy.linalg.norm(dipole_q),
        )
        print >> f, "dipoles (p)    % 10.5f   % 10.5f   % 10.5f   % 10.5f" % (
            dipole_p[0], dipole_p[1], dipole_p[2], numpy.linalg.norm(dipole_p),
        )
        print >> f, "q and p        % 10.5f   % 10.5f   % 10.5f   % 10.5f" % (
            dipole_qp[0], dipole_qp[1], dipole_qp[2], numpy.linalg.norm(dipole_qp),
        )
        print >> f, "total density  % 10.5f   % 10.5f   % 10.5f   % 10.5f" % (
            dipole_qm[0], dipole_qm[1], dipole_qm[2], numpy.linalg.norm(dipole_qm),
        )
        print >> f, "------------------------------------------------------------------"
        print >> f, "Reproduction of the external molecular ESP ..."
        print >> f, "                     RMSD             RMS       CORRELATION"
        print >> f, "charges (q)      % 10.5e    % 10.5e      % 5.2f" % (
            self.mol_esp_cost.rmsd(self.charges),
            self.mol_esp_cost.model_rms(self.charges),
            self.mol_esp_cost.correlation(self.charges),
        )
        print >> f, "dipoles (p)      % 10.5e    % 10.5e      % 5.2f" % (
            self.mol_esp_cost.rmsd(None, self.dipoles),
            self.mol_esp_cost.model_rms(None, self.dipoles),
            self.mol_esp_cost.correlation(None, self.dipoles),
        )
        print >> f, "q and p          % 10.5e    % 10.5e      % 5.2f" % (
            self.mol_esp_cost.rmsd(self.charges, self.dipoles),
            self.mol_esp_cost.model_rms(self.charges, self.dipoles),
            self.mol_esp_cost.correlation(self.charges, self.dipoles),
        )
        print >> f, "total density                    % 10.5e" % self.mol_esp_cost.rms
        f.close()
        log("Written %s" % filename)


    @OnlyOnce("Evaluating orbitals on atomic grids")
    def do_atgrids_orbitals(self):
        self.do_atgrids()
        molecule = self.context.wavefn.molecule
        num_orbitals = self.context.wavefn.num_orbitals
        workdir = self.context.workdir

        pb = log.pb("Computing/Loading orbitals", molecule.size)
        for i, number_i in enumerate(molecule.numbers):
            pb()
            self.context.wavefn.compute_orbitals(self.atgrids[i])
        pb()

    @OnlyOnce("Atomic overlap matrix elements")
    def do_atgrids_overlap(self):
        self.do_atgrids()

        def do_one_spin(spin):
            # first check for restricted
            molecule = self.context.wavefn.molecule
            if spin=="beta" and self.context.wavefn.restricted:
                # sply make references to alpha data and return
                for i in xrange(molecule.size):
                    self.atgrids[i].beta_overlap = self.atgrids[i].alpha_overlap
                return
            # then try to load the matrices
            some_failed = False
            num_orbitals = self.context.wavefn.num_orbitals
            for i in xrange(molecule.size):
                matrix = self.atgrids[i].load("%s_%s_overlap" % (self.prefix, spin))
                if matrix is None:
                    some_failed = True
                else:
                    matrix = matrix.reshape((num_orbitals, num_orbitals))
                setattr(self.atgrids[i], "%s_overlap" % spin, matrix)

            if some_failed:
                self.do_atgrids_orbitals()
                self.do_atgrids_atweights()

                pb = log.pb("Computing atomic overlap matrices (%s)" % spin, molecule.size)
                for i, number_i in enumerate(molecule.numbers):
                    pb()
                    if getattr(self.atgrids[i], "%s_overlap" % spin) is None:
                        orbitals = getattr(self.atgrids[i], "%s_orbitals" % spin)
                        w = self.atgrids[i].atweights
                        matrix = numpy.zeros((num_orbitals,num_orbitals), float)
                        rs = self.get_rs(i, number_i)
                        for j1 in xrange(num_orbitals):
                            for j2 in xrange(j1+1):
                                integrand = orbitals[j1]*orbitals[j2]*w
                                radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                                value = integrate_log(rs, radfun*rs**2)
                                matrix[j1,j2] = value
                                matrix[j2,j1] = value
                        setattr(self.atgrids[i], "%s_overlap" % spin, matrix)
                        self.atgrids[i].dump("%s_%s_overlap" % (self.prefix, spin), matrix)
                pb()

            filename = os.path.join(self.context.outdir, "%s_%s_overlap.txt" % (self.prefix, spin))
            f = file(filename, "w")
            print >> f, "number of orbitals:", num_orbitals
            print >> f, "number of atoms: ", molecule.size
            for i, number_i in enumerate(molecule.numbers):
                print >> f, "Atom %i: %s" % (i, periodic[number_i].symbol)
                matrix = getattr(self.atgrids[i], "%s_overlap" % spin)
                for row in matrix:
                    print >> f, " ".join("% 15.10e" % value for value in row)
            f.close()
            log("Written %s" % filename)

        do_one_spin("alpha")
        do_one_spin("beta")

    @OnlyOnce("Bond orders and atomic valences")
    def do_bond_orders(self):
        # first try to load the results from the work dir
        bond_orders_fn_bin = os.path.join(self.context.workdir, "%s_bond_orders.bin" % self.prefix)
        valences_fn_bin = os.path.join(self.context.workdir, "%s_valences.bin" % self.prefix)
        molecule = self.context.wavefn.molecule
        if os.path.isfile(bond_orders_fn_bin) and os.path.isfile(valences_fn_bin):
            self.bond_orders = numpy.fromfile(bond_orders_fn_bin).reshape((molecule.size, molecule.size))
            self.valences = numpy.fromfile(valences_fn_bin)
        else:
            self.do_charges()
            self.do_atgrids_overlap()

            self.bond_orders = numpy.zeros((molecule.size, molecule.size))
            self.valences = numpy.zeros(molecule.size)
            num_orbitals = self.context.wavefn.num_orbitals
            n_alpha = self.context.wavefn.num_alpha
            n_beta = self.context.wavefn.num_beta

            pb = log.pb("Computing bond orders", (molecule.size*(molecule.size+1))/2)
            for i in xrange(molecule.size):
                for j in xrange(i+1):
                    pb()
                    bo = 2*(
                        (self.atgrids[i].alpha_overlap[:n_alpha,:n_alpha]*
                         self.atgrids[j].alpha_overlap[:n_alpha,:n_alpha]).sum()+
                        (self.atgrids[i].beta_overlap[:n_beta,:n_beta]*
                         self.atgrids[j].beta_overlap[:n_beta,:n_beta]).sum()
                    )
                    if i==j:
                        # compute valence
                        self.valences[i] = 2*self.populations[i] - bo
                    else:
                        # compute bond order
                        self.bond_orders[i,j] = bo
                        self.bond_orders[j,i] = bo
            pb()
            self.bond_orders.tofile(bond_orders_fn_bin)
            self.valences.tofile(valences_fn_bin)

        bond_orders_fn = os.path.join(self.context.outdir, "%s_bond_orders.txt" % self.prefix)
        dump_atom_matrix(bond_orders_fn, self.bond_orders, molecule.numbers, "Bond order")
        log("Written %s" % bond_orders_fn)

        valences_fn = os.path.join(self.context.outdir, "%s_valences.txt" % self.prefix)
        dump_atom_scalars(valences_fn, self.valences, molecule.numbers, "Valences")
        log("Written %s" % valences_fn)

        free_valences_fn = os.path.join(self.context.outdir, "%s_free_valences.txt" % self.prefix)
        self.free_valences = self.valences - self.bond_orders.sum(axis=1)
        dump_atom_scalars(free_valences_fn, self.free_valences, molecule.numbers, "Free valences")
        log("Written %s" % free_valences_fn)

    @OnlyOnce("Atomic weights on other atoms' grids.")
    def do_atgrids_od_atweights(self):
        # od stands for off-diagonal
        self.do_atgrids_atweights()
        self._prepare_atweights()

        molecule = self.context.wavefn.molecule
        pb = log.pb("Computing off-diagonal atom weights", molecule.size**2)
        for i in xrange(molecule.size):
            atgrid = self.atgrids[i]
            atgrid.od_atweights = []
            for j in xrange(molecule.size):
                pb()
                w = self._compute_atweights(atgrid, j)
                atgrid.od_atweights.append(w)
        pb()

    def _compute_atweights(self, grid, atom_index):
        raise NotImplementedError

    @OnlyOnce("Gross & net populations")
    def do_gross_net_populations(self):
        gross_net_populations_fn_bin = os.path.join(self.context.workdir, "%s_gross_net_populations.bin" % self.prefix)
        molecule = self.context.wavefn.molecule

        if os.path.isfile(gross_net_populations_fn_bin):
            log("Loading gross & net populations.")
            self.gross_net_populations = numpy.fromfile(gross_net_populations_fn_bin, float).reshape((molecule.size,molecule.size))
        else:
            self.do_atgrids()
            self.do_atgrids_moldens()
            self.do_charges()
            self.do_atgrids_od_atweights()
            self.gross_net_populations = numpy.zeros((molecule.size, molecule.size))
            pb = log.pb("Integrating over products of stockholder weights", (molecule.size*(molecule.size+1))/2)
            for i, number_i in enumerate(molecule.numbers):
                for j, number_j in enumerate(molecule.numbers[:i+1]):
                    pb()
                    if i != j:
                        # Use Becke's integration scheme to split the integral
                        # over two atomic grids.
                        # 1) first part of the integral, using the grid on atom i
                        rs = self.get_rs(i, number_i)
                        delta = (self.atgrids[i].distances[j].reshape((len(rs),-1)) - rs.reshape((-1,1))).ravel()
                        switch = delta/molecule.distance_matrix[i,j]
                        for k in xrange(3):
                            switch = (3 - switch**2)*switch/2
                        switch += 1
                        switch /= 2
                        integrand = switch*self.atgrids[i].od_atweights[j]*self.atgrids[i].atweights*self.atgrids[i].moldens
                        radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                        part1 = integrate_log(rs, radfun*rs**2)
                        # 2) second part of the integral
                        rs = self.get_rs(j, number_j)
                        delta = (self.atgrids[j].distances[i].reshape((len(rs),-1)) - rs.reshape((-1,1))).ravel()
                        switch = delta/molecule.distance_matrix[i,j]
                        for k in xrange(3):
                            switch = (3 - switch**2)*switch/2
                        switch += 1
                        switch /= 2
                        integrand = switch*self.atgrids[j].od_atweights[i]*self.atgrids[j].atweights*self.atgrids[j].moldens
                        radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                        part2 = integrate_log(rs, radfun*rs**2)
                        # Add up and store
                        self.gross_net_populations[i,j] = part1 + part2
                        self.gross_net_populations[j,i] = part1 + part2
                    else:
                        integrand = self.atgrids[i].atweights**2*self.atgrids[i].moldens
                        radfun = integrate_lebedev(self.context.lebedev_weights, integrand)
                        rs = self.get_rs(i, number_i)
                        self.gross_net_populations[i,i] = integrate_log(rs, radfun*rs**2)
            pb()
            self.gross_net_populations.tofile(gross_net_populations_fn_bin)

        gross_net_fn = os.path.join(self.context.outdir, "%s_gross_net_populations.txt" % self.prefix)
        dump_atom_matrix(gross_net_fn, self.gross_net_populations, molecule.numbers, "Gross/Net")


class StockholderCache(BaseCache):
    def do_proatomfns(self):
        raise NotImplementedError

    def _prepare_atweights(self):
        self.do_proatomfns()

    def _compute_atgrid_atweights(self):
        molecule = self.context.wavefn.molecule
        for i in xrange(molecule.size):
            self.atgrids[i].atweights = self._compute_atweights(
                self.atgrids[i], i
            )

    def _compute_atweights(self, grid, atom_index):
        """Return the weight of atom with given index in the given grid points
        """
        molecule = self.context.wavefn.molecule
        # construct the pro-atom and pro-molecule on this grid
        pro_atom = self.proatomfns[atom_index].density(grid.distances[atom_index])
        pro_mol = numpy.zeros(len(pro_atom), float)
        for j in xrange(molecule.size):
            pro_mol += self.proatomfns[j].density(grid.distances[j])
        # multiply the density on the grid by the weight function
        return pro_atom/pro_mol


class TableBaseCache(StockholderCache):
    @classmethod
    def new_from_args(cls, context, args):
        if len(args) == 1:
            atom_table = AtomTable(args[0])
        else:
            raise ParseError("The Hirshfeld schemes require one scheme argument.")
        return cls(context, atom_table)

    def __init__(self, context, atom_table, prefix):
        self.atom_table = atom_table
        BaseCache.__init__(self, context, prefix)
        # write the rs to the workdir for plotting purposes:
        atom_table.rs.tofile(os.path.join(self.context.workdir, "rs.bin"))

    def get_rs(self, i, number_i):
        if number_i == 0:
            return self.atom_table.rs
        else:
            return self.atom_table.records[number_i].rs


hirshfeld_usage = """ * Hirshfeld Partitioning
     scheme = hirsh
     scheme parameters = densities.txt

     The file densities.txt is generated with the script hi-atomdb.py. It
     cotains spherically averaged densities of individual atoms. Make sure all
     the atoms present in the molecule of interest are included in the file
     densities.txt

     Hirshfeld, F. L. Theor. Chim. Acta 1977, 44, 129-138.
     http://dx.doi.org/10.1007/BF00549096
"""

class HirshfeldCache(TableBaseCache):
    key = "hirsh"
    usage = hirshfeld_usage

    def __init__(self, context, atom_table):
        TableBaseCache.__init__(self, context, atom_table, "hirsh")

    @OnlyOnce("Conventional Hirshfeld (with neutral pro-atoms)")
    def do_proatomfns(self):
        self.do_atgrids()
        molecule = self.context.wavefn.molecule
        self.proatomfns = []
        for i, number_i in enumerate(molecule.numbers):
            self.proatomfns.append(self.atom_table.records[number_i].get_atom_fn(0.0))


hirshfeld_i_usage = """ * Hirshfeld-I Partitioning
     scheme = hirshi
     scheme parameters = densities.txt

     The file densities.txt is generated with the script hi-atomdb.py. It
     cotains spherically averaged densities of individual atoms. Make sure all
     the atoms present in the molecule of interest are included in the file
     densities.txt

     Bultinck, P.;  Van Alsenoy, C.;  Ayers, P. W.;  Dorca, R. C. J. Chem. Phys.
     2007, 126, 144111.
     http://dx.doi.org/10.1063/1.2715563
"""

class HirshfeldICache(TableBaseCache):
    key = "hirshi"
    usage = hirshfeld_i_usage

    def __init__(self, context, atom_table):
        TableBaseCache.__init__(self, context, atom_table, "hirshi")

    @OnlyOnce("Iterative Hirshfeld")
    def do_proatomfns(self):
        molecule = self.context.wavefn.molecule
        self.do_atgrids_moldens()

        counter = 0
        old_charges = numpy.zeros(molecule.size, float)
        while True:
            # construct the pro-atom density functions, using the densities
            # from the previous iteration.
            self.proatomfns = []
            for i, number_i in enumerate(molecule.numbers):
                self.proatomfns.append(self.atom_table.records[number_i].get_atom_fn(old_charges[i]))

            charges = []
            for i, number_i in enumerate(molecule.numbers):
                fn = self.atgrids[i].moldens*self._compute_atweights(self.atgrids[i], i)
                radfun = integrate_lebedev(self.context.lebedev_weights, fn)
                rs = self.atom_table.records[number_i].rs
                num_electrons = integrate_log(rs, radfun*rs**2)
                charges.append(number_i - num_electrons)

            # ordinary blablabla ...
            charges = numpy.array(charges)
            max_change = abs(charges-old_charges).max()
            log("Iteration %03i    max change = %10.5e    total charge = %10.5e" % (
                counter, max_change, charges.sum()
            ))
            if max_change < self.context.options.threshold:
                break
            counter += 1
            if counter > self.context.options.max_iter:
                raise RuntimeError("Iterative Hirshfeld failed to converge.")
            old_charges = charges


isa_usage = """ * Iterative Stockholder Partitioning
     scheme = isa
     scheme parameters = [r_low r_high steps]

     Three additional parameters must be provided of the file rs.bin is not yet
     present in the work directory. The first two, r_low and r_high, are the
     first and the last point on the logarithmic radial grid in angstrom. The
     third, steps, is the number of grid points on the radial grid.

     This scheme has no parameters.

     Lillestolen, T. C.;  Wheatley, R. J. Chem. Commun. 2008,  5909-5911.
     http://dx.doi.org/10.1039/b812691g
"""

class ISACache(StockholderCache):
    key = "isa"
    usage = isa_usage

    @classmethod
    def new_from_args(cls, context, args):
        if len(args) == 3:
            r_low = float(args[0])*angstrom
            r_high = float(args[1])*angstrom
            steps = float(args[2])
            ratio = (r_high/r_low)**(1.0/(steps-1))
            alpha = numpy.log(ratio)
            rs = r_low*numpy.exp(alpha*numpy.arange(0,steps))
        elif len(args) == 0:
            rs_fn_bin = os.path.join(context.workdir, "rs.bin")
            if os.path.isfile(rs_fn_bin):
                rs = numpy.fromfile(rs_fn_bin)
            else:
                raise ParseError("When no scheme arguments are given for the ISA scheme, the file rs.bin must exist in the workdir.")
        else:
            raise ParseError("The ISA scheme requires zero or three scheme arguments.")
        return cls(context, rs)

    def __init__(self, context, rs):
        self.rs = rs
        BaseCache.__init__(self, context, "isa")
        # write the rs to the workdir for plotting purposes:
        self.rs.tofile(os.path.join(self.context.workdir, "rs.bin"))

    def get_rs(self, i, number_i):
        if number_i == 0:
            return self.rs
        elif hasattr(self, "proatomfns") and len(self.proatomfns) > i:
            return self.proatomfns[i].density.x
        elif hasattr(self, "atgrids") and len(self.atgrids) > i:
            num_shells = len(self.atgrids[i].points)/self.context.num_lebedev
            return self.rs[:num_shells]
        else:
            return self.rs

    @OnlyOnce("Iterative Stockholder Analysis")
    def do_proatomfns(self):
        molecule = self.context.wavefn.molecule
        self.do_atgrids_moldens()

        log("Generating initial guess for the pro-atoms")
        self.proatomfns = []
        for i, number_i in enumerate(molecule.numbers):
            densities = self.atgrids[i].moldens
            profile = densities.reshape((-1,self.context.num_lebedev)).min(axis=1)
            profile[profile < 1e-6] = 1e-6
            rs = self.get_rs(i, number_i)
            self.proatomfns.append(AtomFn(rs, profile))

        counter = 0
        old_charges = numpy.zeros(molecule.size, float)
        while True:
            new_proatomfns = []
            charges = []
            for i, number_i in enumerate(molecule.numbers):
                fn = self.atgrids[i].moldens*self._compute_atweights(self.atgrids[i], i)
                radfun = integrate_lebedev(self.context.lebedev_weights, fn)
                rs = self.get_rs(i, number_i)
                num_electrons = integrate_log(rs, radfun*rs**2)
                charges.append(number_i - num_electrons)
                # add negligible tails to maintain a complete partitioning
                radfun[radfun < 1e-40] = 1e-40
                new_proatomfn = AtomFn(rs, radfun/4*numpy.pi)
                new_proatomfns.append(new_proatomfn)

            # ordinary blablabla ...
            charges = numpy.array(charges)
            max_change = abs(charges-old_charges).max()
            log("Iteration %03i    max change = %10.5e    total charge = %10.5e" % (
                counter, max_change, charges.sum()
            ))
            if max_change < self.context.options.threshold:
                break
            counter += 1
            if counter > self.context.options.max_iter:
                raise RuntimeError("Iterative Stockholder Analysis failed to converge.")
            old_charges = charges
            self.proatomfns = new_proatomfns


# find all usable Cache classes
cache_classes = {}
for x in globals().values():
    if isinstance(x, type) and issubclass(x, BaseCache) and x.key is not None:
        cache_classes[x.key] = x
